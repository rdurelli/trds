\section{Considerações Iniciais}

Como apresentado no Capítulo~\ref{chapter:fundamentacao_teorica}, Seção~\ref{sec:refatoracao}, refatorações são técnicas bem conhecidas que auxiliam desenvolvedores durante a reformulação de um determinado sistema com o objetivo de melhorar atributos internos e ainda possuem a preocupação de preservar o comportamento original do sistema. Em uma linha de pesquisa paralela, como destacado na Seção~\ref{sec:modernizacaoOrientada_Arquitetura} do Capítulo~\ref{chapter:fundamentacao_teorica}, existe a ADM que consiste em nova geração de processos para auxiliar e padronizar as atividades da engenharia reversa; utilizando apenas modelos ao invés de código-fonte como os principais artefatos durante o processo de modernização. O OMG forneça conceitos gerais para a condução de modernização dirigida a modelos por meio da ADM, porém, o grupo OMG não fornece instruções sobre como criar ou aplicar refatorações em instâncias de seus metamodelos. Embora a ADM tenha solicitado um \textit{call for proposal} denominado ADM \textit{Refactoring}\footnote{Até o momento da escrita desta Tese a padronização denominada ADM \textit{Refactoring} estava em estágio de discussão. Assim, uma das principais contribuições deste capítulo é auxiliar na criação e adaptação de soluções de refatorações para o metamodelo KDM.} para propor e desenvolver soluções que auxiliam o engenheiro de modernização durante as atividades de refatorações de sistemas com a utilização do metamodelo KDM até o momento existe uma carência de soluções padronizadas e apoios ferramentais. A ausência de instruções de como criar refatorações já existentes para o metamodelo KDM faz com que engenheiros de modernização criem suas próprias soluções. Usualmente tais soluções tendem a se tornarem proprietárias o que pode dificultar o reúso, diminuindo assim a interoperabilidade, um dos principais objetivos da ADM.

O conjunto de refatoração mais conhecido é o catálogo proposto por~\citeonline{Fowler1999}. Esse catálogo foi proposto primeiramente para ser utilizado em código-fonte, não em modelos, como a UML e KDM. Embora~\citeonline{Fowler1999} tenha criado um catálogo de refatorações para ser utilizado em código-fonte, mais de 60\% das refatorações (44 de 72) são ilustradas e explicadas utilizando modelos. Esta observação levanta a questão se refatorações \aspas{tradicionais}, ou seja, aquelas aplicadas em código-fonte, podem ser criadas para modelos como o KDM. ~\citeonline{Zhang_2005, Boger_2003} afirmam que algumas refatorações, por exemplo, \texttt{Extract Method}, são mais naturais quando executadas diretamente no código-fonte. Outras refatorações, como, \texttt{Rename Class}, \texttt{Pull Up Method}, \texttt{Push Down Method}, etc, podem ser aplicadas tanto em código-fonte quando em modelos; já as refatorações que lidam com herança, tais como \texttt{Extract Class}, \texttt{Extract Interface}, \texttt{Replace Inheritance with Delegation}, são mais intuitivas quando aplicadas diretamente em nível de modelo. 

Embora a refatoração no contexto de modelo tenha alcançado bastante reconhecimento e aceitação na literatura~\cite{Moghadam_2012, Maneerat_2011, Fourati_2011, Einarsson_2012, Steimann_2015, Akiyama_2011, Jensen_2010, Arendt_2012, Millan_2009, Tom_2008_2008}, ainda se faz necessário pesquisas nessa área~\cite{durelli_systematic_mapping, revisao_sistematica_uml_refactoring}. Como já salientado até esse momento existe uma ausência de refatoração e apoios computacionais que auxiliem os engenheiros de modernização e os engenheiros de software a criar, reusar e aplicar refatorações de forma consistente para instâncias do metamodelo KDM. Dessa forma, os engenheiros precisam desenvolver suas próprias refatorações, catálogos e apoios computacionais para refatorar sistemas representados em KDM. Como consequência, essas soluções tornam-se difíceis de serem reutilizadas diminuindo assim a interoperabilidade entre as ferramentas de modernização. 

Diante desse contexto, neste capítulo é apresentado uma abordagem para auxiliar o engenheiro de modernização a criar refatorações para o KDM. Essa abordagem contém um conjunto de passos para auxiliar a criação de refatorações para serem aplicadas em instâncias do metamodelo KDM. Para ilustrar a utilização dos passos apresentadas nesse capítulo algumas refatorações proposta por~\citeonline{Fowler1999} são criadas para o metamodelo KDM. Utilizando os passos aqui definidos engenheiros de modernização podem criar refatorações para o metamodelo KDM e facilitar a condução da modernização de um sistema representado como uma instância do metamodelo KDM~\cite{durelli_catalogo, durelli_VEM_ferramenta}. Também é apresentado um mapeamento entre o paradigma orientada a objetos (POO) e o metamodelo KDM. Por meio desse mapeamento outros engenheiros de modernização podem adaptar novas refatorações para o metamodelo KDM facilmente. Nota-se que esse capítulo é uma extensão do seguinte artigo: \textit{Towards a Refactoring Catalogue for Knowledge Discovery Metamodel}~\cite{durelli_catalogo}.



%As refatorações apresentadas e adaptadas neste capítulo são baseadas no catálogo de refatoração do~\citeonline{Fowler1999}. O intuito dessas refatorações é facilitar a condução da modernização de um determinado sistema legado representado como uma instância do metamodelo KDM~\cite{durelli_catalogo, durelli_VEM_ferramenta}. Ainda neste capítulo é apresentado um mapeamento entre os conceitos do paradigma orientado a objetos para o metamodelo KDM, assim, engenheiros de modernização podem de forma mais fácil adaptar novas refatorações para o metamodelo KDM. Nota-se que esse capítulo é uma extensão do seguinte artigo: \textit{Towards a Refactoring Catalogue for Knowledge Discovery Metamodel}~\cite{durelli_catalogo}.

%Com o intuito de apresentar e facilitar o entendimento da criação de refatorações para o KDM de uma maneira mais prática, neste capítulo um conjunto de diretrizes são apresentadas. É importante destacar que 

As refatorações aqui criadas são implementadas com o uso da ATL~\cite{Allilaire_06, Jouault_2005, Jouault_2008} e suas restrições (pre- e pós-condições) são implementadas utilizando OCL. ATL e OCL foram escolhidas nesta Tese pois ambas são linguagens bem conhecidas e amplamente utilizadas na literatura. Porém, ressalta-se que as refatorações, bem como as pré- e pós-condições podem ser adaptadas com o uso de outras tecnologias, como, por exemplo, \textit{Query/View/Transformation}~\cite{QVT:OMG}, EMF Henshin~\cite{EMF_Henshin}, SmartQVT~\cite{SmartQVT}, ModelMorf~\cite{ModelMorf}, Kermeta~\cite{kermeta}, \textit{Epsilon Transformation Language}~\cite{ETL_eclipse}, OpenArchitectureWare~\cite{OpenArchitectureWare}, VIATRA~\cite{viatra}, AndroMDA~\cite{andromda} e Fujaba \textit{transformations}~\cite{fujaba}.

As demais seções desta capítulo estão organizadas da seguinte forma: Na Seção~\ref{sec:estrategiasParaAdaptarRefatoracoesParaOMetamodeloKDM} é apresentado a abordagem de criação de refatorações para o metamodelo KDM. Essa abordagem possui cinco passos: (\textit{i}) identificar elementos estruturais, (\textit{ii}) identificar operações; (\textit{iii}) implementar refatoração; (\textit{iv}) definir restrições e (\textit{v}) especificar refatoração. Na Seção~\ref{sec:catalogo_refatoracao_kdm} são apresentados exemplos de uso da abordagem; e na Seção~\ref{sec:consideracoes_finais_capitulo_reforacao} as considerações finais desse capítulo são apresentadas.

%\change{terminar aqui. Deve colocar todas as seções bem escritas.}

\section{Abordagem para Criar Refatorações para o Metamodelo KDM}\label{sec:estrategiasParaAdaptarRefatoracoesParaOMetamodeloKDM}

Refatorações aplicadas em nível de modelos são transformações especiais que são aplicadas em instâncias de modelos para melhorar sua estrutura e ainda preservar suas características internas. Esse tipo de refatoração é uma área relativamente nova quando comparada com refatorações aplicadas em código-fonte. Com base em informações obtidas das refatorações tradicionais e de abordagens dirigidas por modelos, foi possível definir passos para auxiliar o engenheiro de modernização a criar refatorações para o metamodelo KDM. Os passos apresentados nesse capítulo utilizam um conjunto de elementos distintos, os quais são essenciais para a criação e definição de refatorações para o contexto da ADM e KDM. Esses elementos são apresentados a seguir:

\begin{itemize}
\item Mapeamento entre POO e KDM: Mapear os conceitos do POO para o metamodelo KDM (ver Subseção~\ref{sec:mapeamento_POO_e_KDM}). Refatorações são aplicadas em elementos de código, tais como: classes, interfaces, atributos, métodos, etc. Assim, é de suma importância que os engenheiros de modernização saibam identificar quais são as metaclasses em KDM que representam os elementos que serão refatorados;

\item Operações atômicas/compostas: Identificar as operações que compõem uma determinada refatoração (ver Subseção~\ref{sec:refatoracao_para_o_metamodelo_kdm}); As refatorações podem ser agrupadas em nível de granularidade: (\textit{i}) operações atômicas e (\textit{ii}) operações compostas;

\item Linguagem de Transformação de Modelo: Utilizar \textit{templates} para criar a refatoração. Refatorações são transformações que são aplicadas em determinadas elementos, no contexto desta Tese em instâncias das metaclasses do KDM. Assim, os elementos estruturais juntamente com a linguagem de transformação de modelo formam o sistema de transformação (ver Subseção~\ref{sec:linguagemDeTransformacaoUtilizada});

\item Linguagem de Restrições: Utilizar uma linguagem de restrição para garantir a preservação de comportamento (semântica e sintaxe) ao aplicar uma refatoração. Instâncias do metamodelo KDM são entidades não executáveis, assim, se faz necessário a utilização de linguagens de restrições para garantir a correta execução da refatoração antes e depois de sua aplicação (ver Subseção~\ref{sec:linguagem_de_restricao});

\item Especificação: Definir um modelo de como as refatorações são informalmente e formalmente apresentadas e documentadas (ver Subseção~\ref{sec:template_refatoracao});

\item Gerenciamento de Consistência: Refatorar uma instância de um determinado modelo pode fazer com que o mesmo fique inconsistente. Para preservar consistência entre as visões da instância do modelo abordagens de preservação de consistência precisam ser adotadas (ver Capítulo~\ref{chapter:ferramenta_kdm_re} Seção~\ref{sec:modulo_de_sincronizacao_kdm_re});

\item Apoio Computacional: Implementar um apoio computacional para auxiliar o engenheiro de software a aplicar a refatoração de forma transparente e instâncias do metamodelo KDM (ver Capítulo~\ref{chapter:ferramenta_kdm_re}).
\end{itemize}

No contexto desta Tese cada refatoração criada para o metamodelo KDM consiste de uma transformação que é executada em uma instância do metamodelo KDM. Além disso, as refatorações também possuem pré- e pós-condições que devem ser satisfeitas antes e depois da transformação/refatoração ser executada. Por exemplo, a refatoração \texttt{Remove ClassUnit} tem como pré-condição que uma determinada instância de \texttt{ClassUnit} deve existir na instância do KDM a ser refatoração e não ser referenciada. Nota-se que a definição de refatoração no contexto desta Tese engloba transformações que preservam o comportamento no contexto de modelos. No contexto do metamodelo KDM a preservação de comportamento é alcançado por meio do pacote \texttt{Action}, o qual é apresentado no Capítulo~\ref{chapter:catalogo_refactoring_KDM}, Seção~\ref{sec:actionPackage}. Além disso, é importante destacar que, apenas a semântica e sintaxe são garantidas e preservadas no contexto de Tese após a aplicação de refatorações no KDM. Garantir que a saída/resultado de um sistema representado por meio do KDM não mude após a aplicação de refatorações não é o objetivo desta Tese uma vez que a instância do KDM não podem ser executada. Neste contexto, apenas as semântica e sintaxe da instância do KDM são preservadas. Dessa forma, a Definição~\ref{def:refatoracao} formaliza refatorações no contexto desta Tese:


\begin{definicao}\label{def:refatoracao}
    \textit{Uma refatoração é uma tripla ordenada $R = (pre, T, pos)$ onde \textbf{pre} é uma asserção (ou seja, pré-condição) que deve ser verdade em uma determinada instância \textbf{R} do metamodelo KDM, \textbf{T} consiste na transformação do modelo \textbf{R}, e \textbf{pos} é a pós-condição a ser aplicada após \textbf{T} ser executada.}
\end{definicao}


Na Figura~\ref{fig:diretrizes_kdm_refatoracao_capitulo} é apresentada uma macro-visão dos elementos utilizados para a criação de refatorações para o KDM utilizando a notação \sigla{SADT}{\textit{Structured Analysis and Design Technique}}~\cite{Marca_1987}. Como observado um conjunto de elementos são utilizados como base para a criação de refatorações para o KDM: operações atômicas, \textit{templates}, linguagens de transformações, linguagens de restrições e mapeamento POO - KDM. 

\begin{figure}[h]
	\centering
	% Requires \usepackage{graphicx}
	\caption{Macrovisão para a criação de refatorações para o KDM.}
	\label{fig:diretrizes_kdm_refatoracao_capitulo}
	\includegraphics[scale=0.9]{images/novoMacroAbordagemKDMRefactoring2}
	\fautor
\end{figure}


Na Figura~\ref{fig:todos_os_passos_diretrizes} uma micro-visão da Figura~\ref{fig:diretrizes_kdm_refatoracao_capitulo} é apresentada. Nota-se que a criação de refatorações para o metamodelo KDM possui cinco principais passos que o engenheiro de modernização deve seguir. Nas subseções a seguir esses passos são apresentadas. %Gerenciamento de consistência e Apoio computacional são apresentados no Capítulo~\ref{chapter:Abordagem_de_sincronizacao} e Capítulo~\ref{chapter:ferramenta_kdm_re}, respectivamente.


\begin{figure}[h]
	\centering
	% Requires \usepackage{graphicx}
	\caption{Passos para criar refatorações para o KDM.}
	\label{fig:todos_os_passos_diretrizes}
	\includegraphics[scale=0.7]{images/novaAbordagemCriarRefatoracao3}
	\fautor
\end{figure}

\subsection{Identificar Elementos Estruturais}\label{sec:mapeamento_POO_e_KDM}

Neste passo o objetivo é traduzir os conceitos do POO para o metamodelo KDM. É identificado os elementos estruturais do POO em relação as metaclasses disponíveis no metamodelo KDM. De acordo com~\citeonline{Zhang_2005, Boger_2003} um dos maiores desafios quando necessita-se adaptar refatorações para um determinado metamodelo é saber quais são as metaclasses corretas que representam determinadas construções/declarações de um determinado paradigma de programação. É importante identificar se a metaclasse escolhida para fazer a refatoração representa realmente o elemento e o conceito do POO. Dessa forma, antes de realizar a criação de qualquer refatoração para o metamodelo KDM, deve-se primeiramente identificar as metaclasses do KDM que têm características similares aos conceitos do POO, bem como instruções comumente utilizadas em todas as linguagens de programação, tais como, ramificações, iterações, etc. 

Um mapeamento entre os conceitos/elementos do POO e as metaclasses do metamodelo KDM foi realizado. Esse mapeamento pode ser visto na Tabela~\ref{tab:mapemanetoEntreOOPeKDM}. Nessa tabela é possível visualizar as metaclasses do metamodelo KDM que possuem características similares aos conceitos/elementos do POO. Utilizando essa Tabela~\ref{tab:mapemanetoEntreOOPeKDM}, engenheiros de modernização podem identificar os elementos estruturais necessários para criar as refatorações para o metamodelo KDM. Assim, qualquer exemplo de refatoração definida para o POO pode ser adaptada para o metamodelo KDM. Como observado, a Tabela~\ref{tab:mapemanetoEntreOOPeKDM} contém três colunas: \aspas{Elemento do Código-fonte}, \aspas{Pacote::metaclasse do KDM} e \aspas{Descrição}. A primeira coluna informa a construção da linguagem de programação (\textit{statement})e/ou o conceito do POO (pacote, classe, interface, etc), respectivamente. Em seguida a coluna \aspas{Pacote::metaclasse do KDM} apresenta a metaclasse responsável por mapear a construção e/ou o conceito do POO. Note que essa coluna segue o formato \aspas{\textit{Package}::\textit{Meta-class}}. A ultima coluna, \aspas{Descrição}, possui informações sobre a metaclasse, tais como: seu propósito, seus meta-atributos e suas meta-associações.

\begin{longtable}[c]{| m{1.9cm} | m{3.57cm}| m{9.3cm} |}
 \caption{Mapeamento entre POO e metaclasses do metamodelo KDM.\label{tab:mapemanetoEntreOOPeKDM}}\\
 
 \hline
 \multicolumn{3}{| c |}{Início da Tabela}\\
 \hline
 Elemento do Código-Fonte & Pacote::metaclasse do KDM & Descrição\\
 \hline
 \endfirsthead
 
 \hline
 \multicolumn{3}{|c|}{Continuação da Tabela~\ref{tab:mapemanetoEntreOOPeKDM}}\\
 \hline
 Elemento do Código-Fonte & Pacote::metaclasse do KDM & Descrição\\
 \hline
 \endhead
 
 \hline
 \endfoot
 
 \hline
 \multicolumn{3}{| c |}{Fim da Tabela~\ref{tab:mapemanetoEntreOOPeKDM}}\\
 \hline\hline
 \endlastfoot
 
 Pacote & code::Package & A metaclasse \texttt{Package} é um contêiner para elementos de programa, como classes e interfaces. Essa metaclasse contém um principal meta-atributo, \texttt{name}, que especifica o nome do pacote. Além disso, esta metaclasse possui uma principal meta-associação \texttt{codeElement:AbstractCodeElement[0..*]} onde, pacotes, classes e interfaces podem ser incluídos. \\ 
\hline
Classe & code::ClassUnit & A metaclasse \texttt{ClassUnit} possui dois principais meta-atributos,  \texttt{name:String} e \texttt{isAbstract:boolean}. O primeiro é utilizado para especificar o nome da classe, o segundo é utilizado para informar se a classe é ou não abstrata. Além disso, essa metaclasse possui três meta-associações: \texttt{attribute:Attribute[0..*]}, \texttt{codeRelation:KDMRelationship[0..*]} e  \texttt{codeElement:AbstractCodeElement[0..*]}. \texttt{attribute} é utilizado para especificar a  visibilidade da classe, ou seja, \textit{public}, \textit{private}, ou \textit{protected}. \texttt{codeRelation} agrupa todos os relacionamentos que uma determinada classe possui, por exemplo, heranças e associações. \texttt{codeElement} agrupa qualquer metaclasse cujo tipo é uma concretização de \texttt{AbstractCodeElement}, como: \texttt{StorableUnit}, \texttt{MethodUnit}, \texttt{MemberUnit}, etc. \\ 
\hline
Interface & code::InterfaceUnit & A metaclasse \texttt{InterfaceUnit} possui características similares a metaclasse \texttt{ClassUnit}, porém, não tem o meta-atributo \texttt{isAbstract}, uma vez que todas as interfaces são abstratas por padrão. \\ 
\hline
Atributo & code::StorableUnit & A metaclasse \texttt{StorableUnit} possui dois principais meta-atributos: \texttt{name:String} e \texttt{kind:StorableKind}. Similarmente, esse metaclasse possui duas principais meta-relacionamentos: \texttt{attribute:Attribute[..*]} e \texttt{type:DataType[1]}. \texttt{name} é utilizado para especificar o nome do atributo. \texttt{kind} é uma enumeração utilizada para especificar propriedades do atributo, ou seja, informar se o mesmo é local, global, estático, etc. \texttt{attribute} é utilizado para definir o escopo do atributo, \textit{public}, \textit{private}, ou \textit{protected}. E \texttt{type} é utilizado para definir o tipo do atributo.  \\ 
\hline
Método & code::MethodUnit & A metaclasse \texttt{MethodUnit} possui dois principais meta-atributos: \texttt{name:String} e \texttt{kind:MethodKind}. \texttt{name} é utilizado para especificar o nome do método. \texttt{kind} é uma enumeração utilizada para especificar propriedades do método, ou seja, informar se o método é \textit{construtor}, \textit{destructor}, \textit{virtual}, \textit{abstract}, etc. Similarmente, esse metaclasse possui dois principais meta-relacionamentos: \texttt{attribute:Attribute[..*]}, \texttt{codeElement:AbstractCodeElement[0..*]}. \texttt{attribute} é utilizado para definir o escopo do método - informar se o mesmo é \textit{public}, \textit{private}, ou \textit{protected}. E \texttt{codeElement} é utilizado para agrupar declarações internas do método, ou seja, assinatura do método, bloco do método, etc.\\ 
\hline
Assinatura do Método & code::Signature & A metaclasse \texttt{Signature} possui um principal meta-atributo, \texttt{name:String}, o qual é utilizado para especificar o nome do método. Além disso, essa metaclasse contém um principal meta-relacionamento denominado \texttt{parameterUnit:ParameterUnit[..*]} que é utilizado para especificar os parâmetros que o método possui.\\ 
\hline
Bloco do Método & action::BlockUnit & A metaclasse \texttt{BlockUnit} representa blocos lógicos e físicos relacionados, por exemplo, blocos de instruções \textit{if}, \textit{for}, \textit{while}, etc. Possui um meta-relacionamento denominado \texttt{codeElement:AbstractCodeElement[0..*]} que é utilizado para agrupar qualquer instruções lógicas ou físicas.\\ 
\hline
Parâmetro & code::ParameterUnit & A metaclasse \texttt{ParameterUnit} pode representar o nome, tipo e a posição dos parâmetros em uma assinatura de método. além de permitir o tipo de parâmetro (valor ou referência). Essa metaclasse contém dois principais meta-atributos: \texttt{name:String} e \texttt{kind:ParameterKind}. O primeiro meta-atributo representa o nome do parâmetro, o segundo meta-atributo é uma enumeração para especificar o tipo de parâmetro (valor ou referência). Além disso, \texttt{ParameterUnit} possui o meta-relacionamento \texttt{type:DataType[1]} para especificar o tipo do parâmetro, esse tipo pode ser tipos primitivos ou outros tipos.\\ 
\hline
Associação & code::HasType & A metaclasse \texttt{HasType} representa relação semântica entre um elemento de dados e seu tipo. Essa meta-calsse possui duas principais meta-relacionamentos: \texttt{from:CodeItem} e \texttt{to:DataType}.\\ 
\hline
Herança \texttt{extends} & code::Extends & A metaclasse \texttt{Extends} representa relação semântica de herança entre duas \texttt{ClassUnits} ou duas \texttt{InterfaceUnits}. Essa relação semântica é representada por dois meta-relacionamentos: \texttt{from:DataType} e \texttt{to:DataType}.\\ 
\hline
Herança \texttt{implements} & code::Implements & A metaclasse \texttt{Implements} representa relação semântica de herança entre uma \texttt{ClassUnit} e uma \texttt{InterfaceUnit}. Similarmente a metaclasse \texttt{Extends} a relação semântica é representada por dois meta-relacionamentos: \texttt{from:DataType} e \texttt{to:DataType}.\\ 
\hline
\textit{if}, \textit{for}, \textit{while}, etc & action::ActionElement & \texttt{ActionElement} representa instruções e declarações de uma determinada linguagem de programação, ou seja, pode ser utilizada para representar ramificações, iterações, etc. \texttt{ActionElement} possui um principal meta-atributo denominado \texttt{kind:String} que representa qual o tipo instrução que a metaclasse esta representando. Essa metaclasse possui dois meta-relacionamentos \texttt{codeElement:AbstractCodeElement[0..*]} e \texttt{actionRelation:ActionRelationship[0..*]}.\\ 
\hline
 \end{longtable}

Na Tabela~\ref{tab:mapemanetoEntreOOPeKDM} é possível ver a relação existente entre os conceitos do POO, bem como algumas instruções de linguagens de programação e as algumas metaclasses do metamodelo KDM. Para atender aos objetivos deste trabalho a Tabela~\ref{tab:mapemanetoEntreOOPeKDM} apresenta apenas as principais metaclasses do KDM, uma vez que seria inviável mapear todas as noventa metaclasses do metamodelo KDM.

Como apresentado na Tabela~\ref{tab:mapemanetoEntreOOPeKDM} algumas metaclasses podem ser diretamente mapeadas com elementos do POO, tais como: classes (\texttt{ClassUnit}), interfaces (\texttt{InterfaceUnit}), atributos (\texttt{StorableUnit}), métodos (\texttt{MethodUnit}), etc. Entretanto, como o KDM tem como objetivo ser um metamodelo independente de plataforma para representar de forma genérica todas as abstrações e paradigmas de programação, algumas construções de programação não possuem uma metaclasse particular. Por exemplo, iterações e ramificações em KDM são representadas utilizando a mesma metaclasse, \texttt{ActionElement}. Esse mapeamento ocorre pois o KDM define uma metaclasse genérica para especificar ramificações e iterações para preservar a independência de plataforma; seria inviável para o metamodelo definir específicas metaclasses para representar ramificações e iterações uma vez que cada linguagem de programação possui um determinada particularidade. Para que o mapeamento fique o mais genérico e independente de plataforma possível a metaclasse \texttt{ActionElement} utiliza o meta-atributo \texttt{kind} que possui os seguintes valores: \textit{variable declaration}, \textit{if}, \textit{for}, \textit{while}, etc.

Com a utilização da Tabela~\ref{tab:mapemanetoEntreOOPeKDM} o engenheiro de modernização pode agora escolher qual refatoração criar para o metamodelo KDM. É de suma importância identificar previamente qual elemento do metamodelo KDM será utilizado durante a refatoração para o engenheiro criar e implementar a refatoração como apresentado na Seção~\ref{sec:linguagemDeTransformacaoUtilizada}. Por exemplo, suponha que o engenheiro de modernização almeja criar a refatoração \texttt{Rename Method}. Dessa forma, utilizando a Tabela~\ref{tab:mapemanetoEntreOOPeKDM} pode-se observar qual é a metaclasse em KDM que representa métodos; métodos em KDM são representados por instâncias da metaclasse \texttt{MethodUnit}, assim, a refatoração torna-se \texttt{Rename MethodUnit}. Adicionalmente, por meio da Tabela~\ref{tab:mapemanetoEntreOOPeKDM} é possível identificar todos os relacionamentos que a metaclasse \texttt{MethodUnit} possui, os quais podem ser úteis durante a implementação da refatoração.


\subsection{Identificar Operações}\label{sec:refatoracao_para_o_metamodelo_kdm}

Após identificar todos os elementos estruturais e identificar o mapeamento entre POO e o metamodelo KDM, o próximo passo é identificar as operações que compõem a refatoração a ser criada. Como já salientado, no contexto desta Tese todas as refatorações são transformações que são realizadas em instâncias do KDM. Assim, as refatorações podem ser agrupadas em nível de sua granularidade. As granularidades podem ser definidas em dois níveis de operações: (\textit{i}) operações atômicas e (\textit{ii}) operações compostas. As granularidades definidas como operações atômicas podem ser especificadas por meio de operações primitivas que são executadas na instância do metamodelo KDM. Tais operações primitivas são listadas a seguir



%escolher qual refatoração criar. Dessa forma, nesta seção algumas refatorações propostas por~\citeonline{Fowler1999} foram escolhidas para serem adaptadas para o contexto do metamodelo KDM. As refatorações propostas por~\citeonline{Fowler1999} foram escolhidas para serem adaptas para o contexto do metamodelo KDM uma vez que são bem conhecidas, básicas e de baixa granularidade. As refatorações adaptadas seguem a mesma convenção de nomenclatura definida por~\citeonline{Fowler1999}. Porém, os nomes de algumas refatorações foram alteradas para indicar o metamodelo KDM como seu novo domínio de aplicação, por exemplo, \texttt{MoveMethod} torna-se \texttt{MoveMethodUnit} e \texttt{MoveAttribute} torna-se \texttt{MoveStorableUnit}, etc. 

%No contexto desta Tese todas as refatorações são transformações que são realizadas em uma instância do metamodelo KDM. Assim, as refatorações podem ser agrupadas em nível de sua granularidade. As granularidades podem ser definidas em dois níveis de operações: (\textit{i}) operações atômicas e (\textit{ii}) operações compostas. As granularidades definidas como operações atômicas podem ser especificadas por meio de operações primitivas que são executadas na instância do metamodelo KDM. Tais operações primitivas são listadas a seguir:

\begin{itemize}
\item \texttt{add}: qualquer operação que adicione uma instância de uma metaclasse do metamodelo KDM (ver Tabela~\ref{tab:mapemanetoEntreOOPeKDM});
\item \texttt{delete}: qualquer operação que remove uma instância de uma metaclasse do metamodelo KDM (ver Tabela~\ref{tab:mapemanetoEntreOOPeKDM});
\item \texttt{change}: qualquer operação que altere um valor de um meta-atributo de uma metaclasse do metamodelo KDM (ver Tabela~\ref{tab:mapemanetoEntreOOPeKDM}).
\end{itemize}

As refatorações de granularidade compostas consistem em uma combinação de operações atômicas. Por exemplo, considere a refatoração \texttt{Move ClassUnit}, essa refatoração compõe-se de duas operações atômicas: \texttt{add} e \texttt{delete}. Por exemplo, uma nova instância da metaclasse \texttt{ClassUnit} deve ser adicionada no local onde se almeja mover essa instância e em seguida deve-se aplicar a operação atômica \texttt{delete} na instância da metaclasse \texttt{ClassUnit} antiga. Similarmente, por meio da junção dessas operações atômicas é possível criar e adaptar refatorações já existentes na literatura para o KDM. Por exemplo, considere as refatorações propostas por~\citeonline{Fowler1999}. Essas refatorações podem ser facilmente adaptas para o contexto do metamodelo KDM uma vez que são bem conhecidas, básicas e de baixa granularidade. Na Tabela~\ref{tab:refatoringsCatalogo} algumas refatorações propostas por~\citeonline{Fowler1999} são apresentadas ressaltando a granularidade da refatoração e qual(is) a(s) operação(ões) que devem ser utilizadas para criar a refatoração. Note que as refatorações apresentada nessa tabela seguem a mesma convenção de nomenclatura definida por~\citeonline{Fowler1999}. Porém, os nomes de algumas refatorações foram alteradas para indicar o metamodelo KDM como seu novo domínio de aplicação, por exemplo, \texttt{MoveMethod} torna-se \texttt{MoveMethodUnit} e \texttt{MoveAttribute} torna-se \texttt{MoveStorableUnit}, etc.


%Na Tabela~\ref{tab:refatoringsCatalogo} as refatorações que podem ser facilmente criadas para o metamodelo KDM são apresentadas.

\begin{table}[h]
\caption{Refatorações adaptadas para o metamodelo KDM.\label{tab:refatoringsCatalogo}}
\begin{center}
\begin{tabular}{ | m{4.5cm} | m{2.5cm} | m{4cm}| } 
\hline
\multicolumn{1}{|c|}{Refatoração} & \multicolumn{1}{|c|}{Granularidade} & \multicolumn{1}{|c|}{Tipo de Operação}\\ 
\hline
\textit{Add Package} &  Atômica & \texttt{add}\\ 
\hline
\textit{Add ClassUnit} &  Atômica & \texttt{add}\\ 
\hline
\textit{Add StorableUnit} &  Atômica & \texttt{add}\\ 
\hline
\textit{Add MethodUnit} &  Atômica & \texttt{add}\\ 
\hline
\textit{Delete Package} &  Atômica & \texttt{delete}\\ 
\hline
\textit{Delete ClassUnit} &  Atômica & \texttt{delete}\\ 
\hline
\textit{Delete StorableUnit} &  Atômica & \texttt{delete}\\ 
\hline
\textit{Delete MethodUnit} &  Atômica & \texttt{delete}\\ 
\hline
\textit{Rename Package} &  Atômica & \texttt{change}\\ 
\hline
\textit{Rename ClassUnit} &  Atômica & \texttt{change}\\ 
\hline
\textit{Rename StorableUnit} &  Atômica & \texttt{change}\\ 
\hline
\textit{Rename MethodUnit} &  Atômica & \texttt{change}\\ 
\hline
\textit{Move StorableUnit} &  Composta & \texttt{add} $|$ \texttt{delete}\\ 
\hline
\textit{Move MethodUnit} &  Composta & \texttt{add} $|$ \texttt{delete}\\ 
\hline
\textit{Extract ClassUnit} &  Composta & \texttt{add} $|$ \texttt{delete} $|$ \texttt{change}\\
\hline
\textit{Inline ClassUnit} &  Composta & \texttt{change} $|$ \texttt{delete}\\ 
\hline
\textit{Flatten Hierarchy} &  Composta & \texttt{add} $|$ \texttt{delete} $|$ \texttt{change}\\ 
\hline
\textit{Push Down MethodUnit} &  Composta & \texttt{add} $|$ \texttt{delete}\\ 
\hline
\textit{Push Down StorableUnit} &  Composta & \texttt{add} $|$ \texttt{delete}\\ 
\hline
\textit{Pull Up MethodUnit} &  Composta & \texttt{add} $|$ \texttt{delete}\\
\hline
\textit{Pull Up StorableUnit} &  Composta & \texttt{add} $|$ \texttt{delete}\\
\hline
\textit{Extract SubClass} &  Composta & \texttt{add} $|$ \texttt{change}\\
\hline
\textit{Encapsulate StorableUnit} &  Composta & \texttt{add} $|$ \texttt{change}\\
\hline
\end{tabular}
\end{center}
\end{table}

Após o engenheiro de modernização escolher qual refatoração irá criar para o metamodelo KDM e identificar qual(is) é(são) a(s) operação(ões) que compõe(m) a refatoração escolhida o próximo passo é a implementação da refatoração utilizando técnicas e linguagem de transformação em modelo. Na próxima seção maiores informações são apresentadas.

\subsection{Implementar Refatoração}\label{sec:linguagemDeTransformacaoUtilizada}

Na literatura é possível identificar um conjunto de técnicas e linguagens específicas para auxiliar a condução e especificação de transformação de modelos~\cite{Biehl_2010, Mens_2006, Allilaire_06}. As duas abordagens mais utilizadas na literatura para a elaboração e condução de transformações/refatoração de modelos são: (\textit{i}) abordagem de manipulação direta e (\textit{ii}) abordagem de transformação genérica. A primeira abordagem utiliza linguagens de programação tradicional para a aplicação das refatorações. Ferramentas que utilizam essa abordagem utilizam linguagens como Java, C, C++ etc~\cite{Bruneliere_2014}. Usualmente tais linguagens proporcionam uma infraestrutura mínima para organizar as transformações. Algumas características de suma importância para refatorações de modelo como, regras de transformações, preservação de comportamento são, usualmente criadas pelo engenheiro, uma vez que tais linguagens não possuem API para lidar com tais características. Dessa forma, refatorações que utilizam essa abordagem tornam-se dependente de plataformas, afetando assim a reusabilidade das refatorações. 

A segunda abordagem, transformação genérica, utiliza linguagens desenvolvidas especialmente para realizar transformações em modelos, tais como ATL, QVT, Kermeta, etc. Usualmente, tais abordagens são conhecidas como endógenas e são implementadas utilizando técnicas de reescrita de grafo (ver Capítulo~\ref{chapter:fundamentacao_teorica} Seção~\ref{sec:transformacoes_de_modelos}). Diferentemente da primeira abordagem, a segunda abordagem facilita o reúso de refatorações. Por exemplo, utilizando a segunda abordagem o engenheiro de modernização pode criar um conjunto de regras de refatorações por meio de linguagens de transformações genéricas, assim, tais refatorações podem ser invocadas utilizando qualquer linguagem de programação. O engenheiro pode escrever um código em Java que tem como entrada uma instância do metamodelo KDM para ser refatorado, a reforação a ser aplicada nessa instância e um conjunto de parâmetros para realizar a refatoração na instância do metamodelo KDM.

Dado essa motivação, no contexto desta Tese, a segunda abordagem é utilizada. Mais especificamente a linguagem de transformação ATL~\cite{ATL_eclipse,Jouault_2008} foi escolhida para definir e implementar refatorações em instâncias do metamodelo KDM. ATL foi escolhida como linguagem de transformação considerando vários aspectos. Essa linguagem está integrada no ambiente de desenvolvimento Eclipse, o que fornece uma série de recursos padrões para o desenvolvimento (\textit{syntax highlighting} e \textit{debugger}). Além disso, ATL é parte do projeto \textit{Model-To-Model} e possui um grupo\footnote{\texttt{http://www.eclipse.org/forums/}} de discussão ativo, constantemente atualizado, vários exemplos e diversos estudos de casos aplicados até mesmo na indústria utilizam essa linguagem.


ATL possui um modulo de execução denominado \textit{refining} que é utilizado para criar refatorações em nível de modelo. Esse modulo foi introduzido para facilitar a programação de (ou refatoração) transformações. Com o modulo \textit{refining}, os engenheiros de modernização podem se concentrarem no código ATL dedicado à geração de elementos estruturados modificados. Outros elementos estruturados do KDM (por exemplo, aqueles que permanecem inalteradas antes e após a refatoração) são implicitamente processados pelo mecanismo da ATL. O modulo \textit{refining} pode ser utilizado simplesmente substituindo a palavra-chave \texttt{from} pela palavra-chave \texttt{refining}. Obviamente, o modo de \textit{refining} só pode ser utilizado para as transformações endógenas (\aspas{\textit{in-place}}) (ver Capítulo~\ref{chapter:fundamentacao_teorica}, Seção~\ref{sec:transformacoes_de_modelos})


Como apresentado na Seção~\ref{sec:refatoracao_para_o_metamodelo_kdm} as refatorações no contexto desta Tese são agrupadas em dois níveis de operações: (\textit{i}) operações atômicas e (\textit{ii}) operações compostas. As granularidades definidas como operações atômicas são: \texttt{add}, \texttt{delete} e \texttt{change}. Essas operações atômicas podem ser facilmente implementadas em ATL. Dessa forma, um \textit{template} para cada operação atômica é disponibilizado como artefato para auxiliar o engenheiro de modernização a criar genericamente refatorações para o KDM. O \textit{template} para a operação atômica \texttt{add} é apresentado no Código-fonte~\ref{codigo:template_addKDMElement}. As partes fixas dos \textit{templates} são formadas por texto ATL e as partes variantes são formadas por três tipos de instruções: (\textit{i}) argumentos, \textbf{ArgX}\footnote{\textbf{ArgX}, onde \textbf{X} representa um número sequencial do argumentos. \label{foot:Arg}}, demarcadas pelos símbolos \aspas{\textbf{<\#}} e \aspas{\textbf{\#>}} e que devem ser substituídos por \textit{strings} validas na linguagem ATL; (\textit{ii}) argumentos, \textbf{ArgX}\textsuperscript{\ref{foot:Arg}}, demarcadas pelos símbolos \aspas{\textbf{<\%}} e \aspas{\textbf{\%>}} e que devem ser substituídos por metaclasses do metamodelo KDM, por exemplo, \texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc; e (\textit{iii}) argumentos, \textbf{ArgX}\textsuperscript{\ref{foot:Arg}}, demarcados pelos símbolos \aspas{\textbf{<$@$}} e \aspas{\textbf{@>}} que devem ser substituídos de acordo com o domínio do sistema que será aplicado a refatoração, por exemplo, nomes de pacotes, classes, interfaces, atributos, métodos, etc.  

%argumentos, \textbf{ArgX} onde X representa um número cardinal, demarcadas pelos símbolos \aspas{\textbf{<\%}} e \aspas{\textbf{\%>}} ou \aspas{\textbf{<$@$}} e \aspas{\textbf{@>}}. O primeiro símbolo (\aspas{\textbf{<\%}} e \aspas{\textbf{\%>}}) informa para o engenheiro de modernização que metaclasses do KDM devem ser substituídas pelo argumento.

%Deve-se também utilizar outro artefato para auxiliar o engenheiro de modernização a substituir as partes variáveis do \textit{template} de forma correta.

%Outro artefato que deve ser utilizado juntamente com o \textit{template} apresentado no Código-fonte~\ref{codigo:template_addKDMElement} para auxiliar o engenheiro de modernização a criar a operação atômica é a Tabela X. Essa tabela é utilizada como um guia para conduzir o engenheiro de modernização a especificar corretamente os as partes variantes do \textit{template}, ou seja, os argumentos.


\begin{table}
\centering
\caption{Guia para auxiliar a substituir dos argumentos do \textit{template} apresentado no Código-fonte~\ref{codigo:template_addKDMElement}.}
\label{tab:guia_template_operacao_add}
\begin{tabular}{ | m{1.7cm} | m{12cm}| } 
\hline
\multicolumn{1}{|c|}{Argumentos}                                         & \multicolumn{1}{c|}{Valores} \\ \hline
\multicolumn{1}{|c|}{\textbf{<\#Arg1\#>}} & Nome do módulo. Pode-se utilizar qualquer \textit{string} válida na linguagem ATL; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\#Arg2\#>}} & Nome da regra. Pode-se utilizar qualquer \textit{string} válida na linguagem ATL; \\  
\hline
\multicolumn{1}{|c|}{\textbf{<\%Arg3\%>}} & Nome de uma metaclasse (\texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc). Deve-se especificar o nome da metaclasse que conterá a nova instância da metaclasse a ser criada; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<$@$Arg4@>}} & Nome da instância do elemento estrutural especificado no \textbf{<\%Arg3\%>}. Deve-se especificar o nome da instância da metaclasse que conterá a nova instância da metaclasse a ser criada. Esse argumento depende do domínio do sistema que será aplicado a refatoração e é identifica no meta-atributo \texttt{name} das metaclasses do KDM;  \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\%Arg5\%>}} & Nome de uma metaclasse que será instanciado. Deve-se especificar o nome da metaclasse que será criada;  \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<$@$Arg6@>}} & Nome da nova instância que será criada. Deve-se especificar o nome da instância da metaclasse que será criada. Esse argumento também depende do domínio do sistema que será aplicado a refatoração.  \\ 
\hline
\end{tabular}
\end{table}


\begin{codigo}[caption={[\textit{Template} ATL para realizar a operação atômica \texttt{add}.] \textit{Template} ATL para realizar a operação atômica \texttt{add}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:template_addKDMElement}, language=ATL]{Name}
module (*@<\textbf{\#Arg1\#}>@*);
create OUT : MM refining IN : MM;
rule create(*@<\textbf{\#Arg2\#}>@*){
	from
		source : MM!(*@<\textbf{\%Arg3\%}>@*) (source.name = (*@<\textbf{$@$Arg4@}>@*))
	to 
		target: MM!(*@<\textbf{\%Arg3\%}>@*) (
			codeElement (*@$\leftarrow$@*) source.codeElement(*@$\rightarrow$@*)including(newElement)
		),
		newElement: MM!(*@<\textbf{\%Arg5\%}>@*) (
			name (*@$\leftarrow$@*) (*@<\textbf{$@$Arg6@}>@*)
		)
}
\end{codigo}


%para adicionar uma nova instância da metaclasse \texttt{ClassUnit} denominada \texttt{\aspas{novaClassUnit}} no pacote \texttt{com.br.teste}. Como pode ser observado na linha 5 é especificado o nome do pacote (\texttt{\aspas{com.br.teste}}) que é onde a nova instância da \texttt{ClassUnit} será adicionada. A linha 8 representa que a nova instância da \texttt{ClassUnit} será adicionada no associação \texttt{codeElement}. Nas linhas 10-12 uma nova instância da metaclasse \texttt{ClassUnit} é adicionada e seu nome definido como \aspas{novaClassUnit}.

%Mostrar que o Engenheiro de modernização pode adaptar qualquer elemento... Mostrar uma exemplo em ATL onde pode ser substituido pela metaclasse do KDM........

Além do \textit{template} apresentado no Código-fonte~\ref{codigo:template_addKDMElement} outro artefato também deve ser utilizado para auxiliar o engenheiro de modernização a substituir as partes variáveis do \textit{template} de forma correta. Esse artefato é apresentado na Tabela~\ref{tab:guia_template_operacao_add}. Essa tabela é utilizada como um guia para conduzir o engenheiro de modernização a especificar corretamente as partes variantes do \textit{template}, ou seja, os argumentos.

Dado o \textit{template} apresentado no Código-fonte~\ref{codigo:template_addKDMElement}, bem como as Tabelas~\ref{tab:mapemanetoEntreOOPeKDM} e~\ref{tab:guia_template_operacao_add} a combinação desses três artefatos auxiliam/guiam o engenheiro de software a criar a operação atômica \texttt{add} para um determinado elemento estrutural do KDM, ou seja, \texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{Package}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc. Por exemplo, 
%
%
%quando combinado com a Tabela~\ref{x} (os elementos estruturais \texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{Package}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc) e Tabela X auxiliam a originar a operação atômica \texttt{add} para um determinado elemento estrutural do KDM. 
%
%
%os elemennnnnntos estruturais (\texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{Package}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc) apresentado na Tabela~\ref{tab:mapemanetoEntreOOPeKDM} origina uma operação atômica \texttt{add} para um determinado elemento estrutu
%
no Código-fonte~\ref{codigo:exemplo_add_classUnit} é apresentado uma simples ATL criada utilizando esses três artefatos. Os argumentos \textbf{<\#Arg1\#>} e \textbf{<\#Arg2\#>} foram substituídos pelas \textit{Strings} \texttt{add} e \texttt{Class}, respectivamente, ver linhas 1 e 3. Na linha 5 \textbf{<\%Arg3\%>} foi substituído pela metaclasse \texttt{Package}, enquanto que o argumento \textbf{<$@$Arg4$@$>} foi substituído pela \textit{String} \texttt{\aspas{com.br.teste}} a qual representa o nome da instância da metaclasse \texttt{Package} onde uma nova instância da metaclasse \texttt{ClassUnit} será adicionada. Finalmente, os argumentos \textbf{<\%Arg5\%>} e \textbf{<$@$Arg6$@$>} foram substituída pela metaclasse \texttt{ClassUnit} e pela \textit{String} \texttt{\aspas{novaClassUnit}}, ver linhas 10 e 11.  A execução desse código cria uma nova instância da metaclasse \texttt{ClassUnit} denominada \aspas{novaClassUnit} no pacote \aspas{com.br.teste}.

\begin{codigo}[caption={[ATL para realizar a operação atômica \texttt{add} \texttt{ClassUnit}.] ATL para realizar a operação atômica \texttt{add} \texttt{ClassUnit}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:exemplo_add_classUnit}, language=ATL]{Name}
module add;
create OUT : MM refining IN : MM;
rule createClass{
	from
		source : MM!Package (source.name = (*@\aspas{com.br.teste}@*))
	to 
		target: MM!Package (
			codeElement (*@$\leftarrow$@*) source.codeElement(*@$\rightarrow$@*)including(newElement)
		),
		newElement: MM!ClassUnit (
			name (*@$\leftarrow$@*) (*@\aspas{novaClassUnit}@*)
		)
}
\end{codigo}


Similarmente, o engenheiro de modernização pode implementar a operação atômica \texttt{delete} facilmente seguindo um \textit{template}. O \textit{template} responsável pela operação atômica \texttt{delete} é apresentado no Código-fonte~\ref{codigo:template_delete}\footnote{A palavra-chave \texttt{drop} é utilizada na linha 7 do Código-fonte~\ref{codigo:template_delete} para especificar que uma determinada instância será removida.}. Esse \textit{template} também possui partes fixas e partes variantes. As partes fixas são textos em ATL e as partes variantes são formadas por argumentos demarcados pelas instruções \aspas{\textbf{<\#}} e \aspas{\textbf{\#>}}, \aspas{\textbf{<\%}} e \aspas{\textbf{\%>}} e \aspas{\textbf{<$@$}} e \aspas{\textbf{$@$>}}. 
\begin{codigo}[caption={[\textit{Template} ATL para realizar a operação atômica \texttt{delete}.] \textit{Template} ATL para realizar a operação atômica \texttt{delete}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:template_delete}, language=ATL]{Name}
module (*@<\textbf{\#Arg1\#}>@*);
create OUT : MM refining IN : MM;
rule delete(*@<\textbf{\#Arg2\#}>@*) {
  from
      source : MM!(*@<\textbf{\%Arg3\%}>@*) (source.name = (*@<\textbf{$@$Arg4$@$}>@*))
  to
      drop
}
\end{codigo}

O guia para auxiliar o engenheiro de modernização a especificar corretamente as partes variantes do \textit{template} \texttt{delete} é apresentado na Tabela~\ref{tab:guia_template_operacao_delete}. Por meio de três artefatos: (\textit{i}) o \textit{template} representado no Código-fonte~\ref{codigo:template_delete}, (\textit{ii}) o mapeamento entre OO e KDM apresentado na Tabela~\ref{tab:mapemanetoEntreOOPeKDM} e (\textit{iii}) e o guia apresentado na Tabela ~\ref{tab:guia_template_operacao_delete} o engenheiro de modernização pode criar a operação atômica \texttt{delete}. Por exemplo, considere o Código-fonte~\ref{codigo:exemplo_delete_classUnit} onde almeja-se remover uma instância da metaclasse \texttt{ClassUnit}. 


\begin{table}[h]
\centering
\caption{Guia para auxiliar a substituir dos argumentos do \textit{template} apresentado no Código-fonte~\ref{codigo:template_delete}.}
\label{tab:guia_template_operacao_delete}
\begin{tabular}{ | m{1.7cm} | m{12cm}| } 
\hline
\multicolumn{1}{|c|}{Argumentos}                                         & \multicolumn{1}{c|}{Valores} \\ \hline
\multicolumn{1}{|c|}{\textbf{<\#Arg1\#>}} & Nome do módulo. Pode-se utilizar qualquer \textit{string} válida na linguagem ATL; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\#Arg2\#>}} & Nome da regra. Pode-se utilizar qualquer \textit{string} válida na linguagem ATL; \\  
\hline
\multicolumn{1}{|c|}{\textbf{<\%Arg3\%>}} & Nome de uma metaclasse (\texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc). Deve-se especificar o nome da metaclasse que representa a instância da metaclasse a ser deletada; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<$@$Arg4@>}} & Nome da instância do elemento estrutural especificado no \textbf{<\%Arg3\%>}. Deve-se especificar o nome da instância da metaclasse que representa a instância da metaclasse a ser deletada. Esse argumento depende do domínio do sistema que será aplicado a refatoração e é identifica no meta-atributo \texttt{name} das metaclasses do KDM;  \\ 
\hline
\end{tabular}
\end{table}

Os argumentos \textbf{<\#Arg1\#>} e \textbf{<\#Arg2\#>} foram substituídos pelas \textit{Strings} \texttt{remove} e \texttt{Class}, respectivamente, ver linhas 1 e 3. Na linha 5 \textbf{<\%Arg3\%>} foi substituído pela metaclasse \texttt{ClassUnit}, enquanto que o argumento \textbf{<$@$Arg4$@$>} foi substituído pela \textit{String} \texttt{\aspas{ClassToRemove}}. Essa \textit{String} representa o nome da instância da \texttt{ClassUnit} que almeja-se deletar.


\begin{codigo}[caption={[ATL para realizar a operação atômica \texttt{delete} \texttt{ClassUnit}.] ATL para realizar a operação atômica \texttt{delete} \texttt{ClassUnit}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:exemplo_delete_classUnit}, language=ATL]{Name}
module remove;
create OUT : MM refining IN : MM;
rule deleteClass {
  from
      source : MM!ClassUnit (source.name = (*@\aspas{ClassToRemove}@*))
  to
      drop
}
\end{codigo}

Finalmente, a operação atômica \texttt{change} também pode ser implementada por meio de \textit{template}. O Código-fonte~\ref{codigo:template_change} representa o \textit{template} da operação atômica \texttt{change}. Esse \textit{template} também possui partes fixas e instruções demarcadas por \aspas{\textbf{<\#}} e \aspas{\textbf{\#>}}, \aspas{\textbf{<\%}} e \aspas{\textbf{\%>}} e \aspas{\textbf{<$@$}} e \aspas{\textbf{$@$>}} que representam as partes variantes.

\begin{codigo}[caption={[\textit{Template} para realizar a operação atômica \texttt{change}.] \textit{Template} para realizar a operação atômica \texttt{change}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:template_change}, language=ATL]{Name}
module (*@<\textbf{\#Arg1\#}>@*);
create OUT : MM refining IN : MM;
rule change(*@<\textbf{\#Arg2\#}>@*) {
	from
		source : MM!(*@<\textbf{\%Arg3\%}>@*) (source.name=(*@<\textbf{$@$Arg4$@$}>@*))
	to 
		target : MM!(*@<\textbf{\%Arg3\%}>@*) (
			(*@<\textbf{\%Arg5\%}>@*) (*@$\leftarrow$@*) (*@<\textbf{$@$Arg6$@$}>@*)
		)
}
\end{codigo}

\begin{table}[h]
\centering
\caption{Guia para auxiliar a substituir dos argumentos do \textit{template} apresentado no Código-fonte~\ref{codigo:template_change}.}
\label{tab:guia_template_operacao_change}
\begin{tabular}{ | m{1.7cm} | m{12cm}| } 
\hline
\multicolumn{1}{|c|}{Argumentos}                                         & \multicolumn{1}{c|}{Valores} \\ \hline
\multicolumn{1}{|c|}{\textbf{<\#Arg1\#>}} & Nome do módulo. Pode-se utilizar qualquer \textit{string} válida na linguagem ATL; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\#Arg2\#>}} & Nome da regra. Pode-se utilizar qualquer \textit{string} válida na linguagem ATL; \\  
\hline
\multicolumn{1}{|c|}{\textbf{<\%Arg3\%>}} & Nome de uma metaclasse (\texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc). Deve-se especificar o nome da metaclasse que conterá a instância da metaclasse a ser alterada; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<$@$Arg4@>}} & Nome da instância do elemento estrutural especificado no \textbf{<\%Arg3\%>}. Deve-se especificar o nome da instância da metaclasse a ser alterada. Esse argumento depende do domínio do sistema que será aplicado a refatoração e é identifica no meta-atributo \texttt{name} das metaclasses do KDM;  \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\%Arg5\%>}} & Nome do(s) meta-atributo(s) da metaclasse que será alterada. Deve-se especificar o(s) nome(s) do(s) meta-atributo(s) que será(ão) alterado(s);  \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<$@$Arg6$@$>}} & Novo(s) valor(es) para ser setado(s) no(s) meta-atributo(s) especificado(s) no \textbf{<\%Arg5\%>}. Esse argumento também depende do domínio do sistema que será aplicado a refatoração.  \\ 
\hline
\end{tabular}
\end{table}

Na Tabela~\ref{tab:guia_template_operacao_change} o guia para auxiliar o engenheiro de modernização a especificar corretamente as partes variantes do \textit{template} \texttt{change} é apresentado. A junção dos três artefatos: (\textit{i}) o \textit{template} apresentado no Código-fonte~\ref{codigo:template_change}, (\textit{ii}) o mapemanto entre OO e KDM (ver Tabela~\ref{tab:mapemanetoEntreOOPeKDM}) e (\textit{iii}) o guia apresentado na Tabela~\ref{tab:guia_template_operacao_change} auxiliam o engenheiro de modernização a criar a operação atômica \texttt{change}. Por exemplo, considere o Código-fonte~\ref{codigo:exemplo_rename_Package} onde esses três artefatos foram utilizados pelo engenheiro de modernização para implementar a operação atômica \texttt{change}. Nesse código-fonte uma determinada instância da metaclasse \texttt{Package} é alterado, ou seja, seu meta-atributo \texttt{name} é renomeado. Assim, os argumentos \textbf{<\#Arg1\#>} e \textbf{<\#Arg2\#>} foram substituídos pelas \textit{Strings} \texttt{renamePackage} e \texttt{rename}, respectivamente, ver linhas 1 e 3. Na linha 5 \textbf{<\%Arg3\%>} foi substituído pela metaclasse \texttt{Package}, enquanto que o argumento \textbf{<$@$Arg4$@$>} foi substituído pela \textit{String} \texttt{\aspas{PackageToRename}} a qual representa o nome da instância da metaclasse \texttt{Package} onde uma nova instância da metaclasse \texttt{ClassUnit} será alterada. O argumento \textbf{<\%Arg5\%>} foi substitudo pelo meta-atributo \texttt{name} e o \textbf{<$@$Arg6$@$>} foi substituído por uma \textit{String} que representa o novo nome da instância da metaclasse \texttt{Package}, ver linha 8.


%A última operação atômica é a operação \texttt{change}. Essa operação é responsável por alterar o valor de um meta-atributo de uma metaclasse do metamodelo KDM, como por exemplo \textit{Rename Package} apresentado no Código-fonte~\ref{codigo:exemplo_rename_Package}. Na linha 5 é especificado e identificado a instância da metaclasse \texttt{Package} que será alterada. Nas linhas 7-9 a instância especificada da metaclasse \texttt{Package} é alterada.

\begin{codigo}[caption={[ATL para realizar a operação atômica \texttt{change} \texttt{ClassUnit}.] ATL para realizar a operação atômica \texttt{change} \texttt{ClassUnit}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:exemplo_rename_Package}, language=ATL]{Name}
module rename;
create OUT : MM refining IN : MM;
rule changePackage {
	from
		source : MM!Package (source.name=(*@\aspas{PackageToRename}@*))
	to 
		target : MM!Package (
			name (*@$\leftarrow$@*) (*@\aspas{newName}@*)
		)
}
\end{codigo}


Como apresentado na Tabela~\ref{tab:refatoringsCatalogo} com a combinação dessas operações atômicas os engenheiros de modernização podem criar refatorações mais significativas. Por exemplo, o Código-fonte~\ref{codigo:exemplo_add_classUnit} e o Código-fonte~\ref{codigo:exemplo_delete_classUnit} ilustram as operações atômicas \texttt{add} e \texttt{delete} para instâncias da metaclasse \texttt{ClassUnit}, respectivamente, assim, a combinação dessas duas operações atômica resulta na refatoração \texttt{move}. %Porém, engenheiros de modernização podem adaptarem esses códigos para utilizam outros elementos estruturais tais como: \texttt{InterfaceUnit}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc. Por exemplo, caso almeja-se deletar uma determinada instância da metaclasse \texttt{InterfaceUnit} o engenheiro de modernização deve apenas substituir a linha 5 do Código-fonte~\ref{codigo:exemplo_delete_classUnit} por \aspas{\texttt{source: MM!InterfaceUnit(source.name = \aspas{InterfaceToRemove})}}. 

Após a criação de uma refatoração o engenheiro de modernização deve especificar as restrições da refatoração criada. Tais restrições são especificadas utilizando linguagens de restrições como por exemplo OCL. Na próxima seção maiores informações são apresentadas.

\subsection{Definir Restrições (Pré- e Pós-condições)}\label{sec:linguagem_de_restricao}

Após o engenheiro de modernização criar uma determinada refatoração o próximo passo consiste na criação de restrições (pré- e pós-condições) para a refatoração. Usualmente antes e após a aplicação de uma determinada refatoração algumas restrições precisam ser satisfeitas. Tais restrições usualmente são úteis para verificar se os parâmetros necessários para executar a refatoração foi completamente e corretamente informando, bem como verificar se a refatoração foi aplicada de forma totalmente correta. No contexto de modelos, tais restrições são especificadas utilizando linguagem como OCL e são caracterizadas como pré- e pós-condições. Utilizando OCL é possível verificar, por exemplo, se todos os parâmetros obrigatórios para executar o mecanismo da refatoração foram especificados pelo modernizador. Além disso, essas condições são importantes para assegurar que a refatoração será aplicada de forma correta e ainda irá preservar a semântica da instância do metamodelo. Dessa forma, cada refatoração definida nesta Tese está associada com uma pré- e pós-condição definida em OCL. OCL foi escolhida pois a mesma é uma linguagem padronizada pela OMG e também possui suporte no ambiente de desenvolvimento Eclipse.

Para auxiliar o engenheiro de modernização durante a criação dessas restrições (pré- e pós-condições) \textit{templates} também foram definidos. Os \textit{templates} aqui apresentados estão associados a uma determinada operação atômica. Por exemplo, para cada operação atômica (\texttt{add}, \texttt{delete} e \texttt{change}) dois \textit{templates} foram definidos para auxiliar a criação das restrições, ou seja, um \textit{template} para auxiliar a criação da pré-condição e outro para auxiliar a criação da pós-condição.

Os \textit{templates} para a operação atômica \texttt{add} é apresentado nos Códigos-fontes~\ref{codigo:pre_template_add} e~\ref{codigo:template_pos_condicao_add}, onde o primeiro código ilustra o \textit{template} da criar a pré-condição e o segundo representa o \textit{template} para especificar a pós-condição da operação atômica \texttt{add}. As partes fixas dos \textit{templates} são formadas por texto em OCL e as partes variantes são formadas por três tipos de instruções: (\textit{i}) argumentos, \textbf{ArgX}\footnote{\textbf{ArgX}, onde \textbf{X} representa um número sequencial do argumentos. \label{foot:Arg1}}, demarcadas pelos símbolos \aspas{\textbf{<\#}} e \aspas{\textbf{\#>}} e que devem ser substituídos por \textit{strings} validas na linguagem OCL; e (\textit{ii}) argumentos, \textbf{ArgX}\textsuperscript{\ref{foot:Arg1}}, demarcadas pelos símbolos \aspas{\textbf{<\%}} e \aspas{\textbf{\%>}} e que devem ser substituídos por elementos/metaclasses do metamodelo KDM, por exemplo, \texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc; e (\textit{iii}) argumentos, \textbf{ArgX}\textsuperscript{\ref{foot:Arg}}, demarcados pelos símbolos \aspas{\textbf{<$@$}} e \aspas{\textbf{@>}} que devem ser substituídos de acordo com o domínio do sistema que será aplicado a refatoração, por exemplo, nomes de pacotes, classes, interfaces, atributos, métodos, etc.  

\begin{codigo}[caption={[\textit{Template} OCL para realizar a pré-condição da operação atômica \texttt{add}.] \textit{Template} OCL para realizar a pré-condição da operação atômica \texttt{add}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:pre_template_add}, language=OCL]{Name}
context (*@<\textbf{\%Arg1\%}>@*)::(*@<\textbf{\#Arg2\#}>@*)(newName: String)
pre : (*@<\textbf{\%Arg3\%}>@*).allInstances->select(e : (*@<\textbf{\%Arg3\%}>@*) | a.name = (*@<\textbf{$@$Arg4$@$}>@*)) and not (*@<\textbf{\%Arg1\%}>@*).refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : (*@<\textbf{\%Arg1\%}>@*) | e.name = newName)
\end{codigo}

O \textit{template} apresentado no Código-fonte~\ref{codigo:pre_template_add} tem como função verificar se uma determinada instância de uma metaclasse a ser criada pela operação atômica \texttt{add} ainda não existe na instância do KDM. Isso é importante para garantir que não exista duas instâncias iguais no KDM. Caso positivo a operação atômica pode ser então executada. A pós-condição apresentada no Código-fonte~\ref{codigo:template_pos_condicao_add} por outro lado verifica se a instância de uma metaclasse realmente foi criada pela execução da operação atômica \texttt{add}.

\begin{codigo}[caption={[\textit{Template} OCL para realizar a pós-condição da operação atômica \texttt{add}.] \textit{Template} OCL para realizar a pós-condição da operação atômica \texttt{add}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:template_pos_condicao_add}, language=OCL]{Name}
context (*@<\textbf{\%Arg1\%}>@*)::(*@<\textbf{\#Arg2\#}>@*)(newName: String)
post : (*@<\textbf{\%Arg3\%}>@*).allInstances->select(e : (*@<\textbf{\%Arg3\%}>@*) | a.name = (*@<\textbf{$@$Arg4$@$}>@*)) and (*@<\textbf{\%Arg1\%}>@*).refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : (*@<\textbf{\%Arg1\%}>@*) | e.name = newName)
\end{codigo}

\begin{table}[h]
\centering
\caption{Guia para auxiliar a substituir dos argumentos dos \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:pre_template_add} e~\ref{codigo:template_pos_condicao_add}.}
\label{tab:guia_template_pre_pos_add}
\begin{tabular}{ | m{1.7cm} | m{12cm}| } 
\hline
\multicolumn{1}{|c|}{Argumentos}                                         & \multicolumn{1}{c|}{Valores} \\ \hline
\multicolumn{1}{|c|}{\textbf{<\%Arg1\%>}} & Nome de uma metaclasse (\texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc). Deve-se especificar o nome da metaclassse que foi criada pela operação atômica \texttt{add}; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\#Arg2\#>}} & Nome da restrição. Pode-se utilizar qualquer \textit{string} válida em OCL; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\%Arg3\%>}} & Nome de uma metaclasse que contém o elemento especificado no \textbf{<\%Arg1\%>}. Por exemplo, se o \textbf{<\%Arg1\%>} for uma \texttt{ClassUnit} e/ou \texttt{InterfaceUnit} deve-se especificar a metaclasse \texttt{Package}; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<$@$Arg4$@$>}} & Nome da instância do elemento estrutural que contém o elemento especificado no \textbf{<\%Arg3\%>}. Esse argumento depende do domínio do sistema que será aplicado a refatoração; \\ 
\hline
\end{tabular}
\end{table}

Além dos \textit{templates} outro artefato também deve ser utilizado para auxiliar o engenheiro de modernização a criar as restrições (pré- e pós-condições). Esse artefato é apresentado na Tabela~\ref{tab:guia_template_pre_pos_add}. Essa tabela é utilizada como um guia para conduzir o engenheiro de modernização a especificar corretamente as partes variantes dos \textit{templates}. Por exemplo, considere que o engenheiro de modernização almeja criar a operação atômica \texttt{add} \texttt{ClassUnit}. Dessa forma, utilizando os \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:pre_template_add} e~\ref{codigo:template_pos_condicao_add}, bem como a Tabela~\ref{tab:guia_template_pre_pos_add} é possível criar as restrições dessa operação atômica como apresentado no Código-fonte~\ref{codigo:template_assercao_juntado_add}. O argumento \textbf{<\%Arg1\%>} foi substituído pela metaclasse \texttt{ClassUnit} e o argumento \textbf{<\#Arg2\#>} foi alterado por uma \textit{String} válida em OCL. O argumento \textbf{<\%Arg3\%>} foi substituído pela metaclasse \texttt{Package} e o  argumento \textbf{<$@$Arg4$@$>} foi  substituído por uma \textit{String} que representa o pacote (\aspas{com.br.util}) onde a instância da metaclasse \texttt{ClassUnit} será adicionada.

\begin{codigo}[caption={[Asserções em OCL para realizar a operação atômica \texttt{add}.] Asserções em OCL para realizar a operação atômica \texttt{add}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:template_assercao_juntado_add}, language=OCL]{Name}
context ClassUnit::preCond(newName: String)
pre : Package.allInstances->select(e : Package | a.name = (*@\aspas{com.br.util}@*)) and not ClassUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : ClassUnit | e.name = newName)
context ClassUnit::postCond(newName: String)
post : Package.allInstances->select(e : Package | a.name = (*@\aspas{com.br.util}@*)) and ClassUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : ClassUnit | e.name = newName)
\end{codigo}

Da mesmo forma o engenheiro de modernização pode implementar as restrições para a operação atômica \texttt{delete} seguinte \textit{templates}. Os \textit{templates} para auxiliar o engenheiro de modernização a implementar as restrições para a operação atômica \texttt{delete} são apresentados nos Códigos-fontes~\ref{codigo:pre_template_delete} e ~\ref{codigo:pos_template_delete}. Similarmente, esses \textit{templates} também possuem partes fixas e instruções demarcados por \textbf{<\%} e \textbf{\%>}, \textbf{<\#} e \textbf{\#>} e \textbf{<\$@} e \textbf{\$@>} que representam as partes variantes.

\begin{codigo}[caption={[\textit{Template} OCL para realizar a pré-condição da operação atômica \texttt{delete}.] \textit{Template} OCL para realizar a pré-condição da operação atômica \texttt{delete}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:pre_template_delete}, language=OCL]{Name}
context (*@<\textbf{\%Arg1\%}>@*)::(*@<\textbf{\#Arg2\#}>@*)(Ename: String)
pre : (*@<\textbf{\%Arg3\%}>@*).allInstances->select(e : (*@<\textbf{\%Arg3\%}>@*) | a.name = (*@<\textbf{$@$Arg4$@$}>@*)) and (*@<\textbf{\%Arg1\%}>@*).refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : (*@<\textbf{\%Arg1\%}>@*) | e.name = Ename)
\end{codigo}

\begin{codigo}[caption={[\textit{Template} OCL para realizar a pós-condição da operação atômica \texttt{delete}.] \textit{Template} OCL para realizar a pós-condição da operação atômica \texttt{delete}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:pos_template_delete}, language=OCL]{Name}
context (*@<\textbf{\%Arg1\%}>@*)::(*@<\textbf{\#Arg2\#}>@*)(Ename: String)
post : (*@<\textbf{\%Arg3\%}>@*).allInstances->select(e : (*@<\textbf{\%Arg3\%}>@*) | a.name = (*@<\textbf{$@$Arg4$@$}>@*)) and not (*@<\textbf{\%Arg1\%}>@*).refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : (*@<\textbf{\%Arg1\%}>@*) | e.name = Ename)
\end{codigo}

O \textit{template} apresentado no Código-fonte~\ref{codigo:pre_template_delete} tem como função verificar se uma determinada instância de uma metaclasse a ser deletada pela operação atômica \texttt{delete} existe na instância do KDM. Caso positivo a operação atômica pode ser então executada. Por outro lado, a pós-condição apresentada no Código-fonte~\ref{codigo:pos_template_delete} verifica se a instância da metaclasse realmente foi deletada após a execução da operação atômica \texttt{delete}. 

\begin{table}[h]
\centering
\caption{Guia para auxiliar a substituir dos argumentos dos \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:pre_template_delete} e ~\ref{codigo:pos_template_delete}.}
\label{tab:guia_template_pre_pos_delete}
\begin{tabular}{ | m{1.7cm} | m{12cm}| } 
\hline
\multicolumn{1}{|c|}{Argumentos}                                         & \multicolumn{1}{c|}{Valores} \\ \hline
\multicolumn{1}{|c|}{\textbf{<\%Arg1\%>}} & Nome de uma metaclasse (\texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc). Deve-se especificar o nome da metaclassse que será deletada pela operação atômica \texttt{delete}; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\#Arg2\#>}} & Nome da restrição. Pode-se utilizar qualquer \textit{string} válida em OCL; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\%Arg3\%>}} & Nome de uma metaclasse que contém o elemento especificado no \textbf{<\%Arg1\%>}. Por exemplo, se o \textbf{<\%Arg1\%>} for uma \texttt{ClassUnit} e/ou \texttt{InterfaceUnit} deve-se especificar a metaclasse \texttt{Package}; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<$@$Arg4$@$>}} & Nome da instância do elemento estrutural que contém o elemento especificado no \textbf{<\%Arg3\%>}. Esse argumento depende do domínio do sistema que será aplicado a refatoração; \\ 
\hline
\end{tabular}
\end{table}

O artefato utilizado para auxiliar e conduzir o engenheiro de modernização especificar corretamente as partes variantes dos \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:pre_template_delete} e ~\ref{codigo:pos_template_delete} é apresentado na Tabela~\ref{tab:guia_template_pre_pos_delete}. 

\begin{codigo}[caption={[Asserções em OCL para realizar a operação atômica \texttt{delete}.] Asserções em OCL para realizar a operação atômica \texttt{delete}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:template_assercao_juntado_delete}, language=OCL]{Name}
context StorableUnit::preCond(Ename: String)
pre : ClassUnit.allInstances->select(e : ClassUnit | a.name = (*@\aspas{Foo}@*)) and StorableUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : StorableUnit | e.name = Ename)
context StorableUnit::postCond(Ename: String)
post : ClassUnit.allInstances->select(e : ClassUnit | a.name = (*@\aspas{Foo}@*)) and  not StorableUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : StorableUnit | e.name = Ename)
\end{codigo}

No Código-fonte~\ref{codigo:template_assercao_juntado_delete} é apresentado as asserções da operação atômica \texttt{delete} quando almeja-se deletar uma instância da metaclasse \texttt{StorableUnit}. Note que o argumento \textbf{<\%Arg1\%>} foi substituído pela metaclasse \texttt{StorableUnit} e o argumento \textbf{<\#Arg2\#>} foi alterado por uma \textit{String} válida em OCL. \textbf{<\%Arg3\%>} foi substituído pela metaclasse \texttt{ClassUnit}. O argumento \textbf{<$@$Arg4$@$>} foi  substituído por uma \textit{String} que representa a classe (\aspas{Foo}) que contém a instância da metaclasse \texttt{StorableUnit} que será deletada. 

\begin{codigo}[caption={[\textit{Template} OCL para realizar a pré-condição da operação atômica \texttt{change}.] \textit{Template} OCL para realizar a pré-condição da operação atômica \texttt{change}.},escapeinside={(*@}{@*)}, mathescape=true, basicstyle=\footnotesize, label={codigo:pre_template_change}, language=OCL]{Name}
context (*@<\textbf{\%Arg1\%}>@*)::(*@<\textbf{\#Arg2\#}>@*)(el: String | Integer | Real | Boolean)
pre : (*@<\textbf{\%Arg1\%}>@*).(*@<\textbf{\%Arg3\%}>@*) <> el
\end{codigo}

Finalmente, as asserções para a operação atômica \texttt{change} também podem ser implementas seguinte os \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:pre_template_change} e~\ref{codigo:post_template_change}. O \textit{template} apresentado no Código-fonte~\ref{codigo:pre_template_change} tem como função verificar se um determinado meta-atributo de uma metaclasse é diferente do valor que almeja-se alterar pela operação atômica \texttt{change}. A pós-condição apresentada no Código-fonte~\ref{codigo:post_template_change} por outro lado verifica se o meta-atributo realmente foi alterado pela execução da operação atômica \texttt{change}.

\begin{codigo}[caption={[\textit{Template} OCL para realizar a pós-condição da operação atômica \texttt{change}.] \textit{Template} OCL para realizar a pré-condição da operação atômica \texttt{change}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:post_template_change}, language=OCL]{Name}
context (*@<\textbf{\%Arg1\%}>@*)::(*@<\textbf{\#Arg2\#}>@*)(el: String | Integer | Real | Boolean)
post : (*@<\textbf{\%Arg1\%}>@*).(*@<\textbf{\%Arg3\%}>@*) = el
\end{codigo}

O guia utilizado pelo engenheiro de modernização para especificar corretamente as partes variantes dos \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:pre_template_change} e ~\ref{codigo:post_template_change} é apresentado na Tabela~\ref{tab:guia_template_pre_pos_change}.

\begin{table}[h]
\centering
\caption{Guia para auxiliar a substituir dos argumentos dos \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:pre_template_change} e ~\ref{codigo:post_template_change}.}
\label{tab:guia_template_pre_pos_change}
\begin{tabular}{ | m{1.7cm} | m{12cm}| } 
\hline
\multicolumn{1}{|c|}{Argumentos}                                         & \multicolumn{1}{c|}{Valores} \\ \hline
\multicolumn{1}{|c|}{\textbf{<\%Arg1\%>}} & Nome de uma metaclasse (\texttt{ClassUnit}, \texttt{InterfaceUnit}, \texttt{StorableUnit}, \texttt{MethodUnit}, etc). Deve-se especificar o nome da metaclassse que almeja-se alterar um meta-atributo por meio da operação atômica \texttt{change}; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\#Arg2\#>}} & Nome da restrição. Pode-se utilizar qualquer \textit{string} válida em OCL; \\ 
\hline
\multicolumn{1}{|c|}{\textbf{<\%Arg3\%>}} & Nome do meta-atributo a ser alterado. Deve-se especificar o meta-atributo da metaclasse especificado no \textbf{<\%Arg1\%>} que almeja-se alterar; \\ 
\hline
\end{tabular}
\end{table}

No Código-fonte~\ref{codigo:template_assercao_juntado_change} é apresentado as asserções da operação atômica \texttt{change} quando almeja-se alterar o meta-atributo \texttt{name} de uma instância da metaclasse \texttt{Package}. O argumento \textbf{<\%Arg1\%>} foi substituído pela metaclasse \texttt{Package}, o argumento \textbf{<\#Arg2\#>} foi alterado por uma \textit{String} válida em OCL e o argumento \textbf{<\%Arg3\%>} foi substituído pelo meta-atributo \texttt{name} da metaclasse \texttt{Package}.

\begin{codigo}[caption={[Asserções em OCL para realizar a operação atômica \texttt{change}.] Asserções em OCL para realizar a operação atômica \texttt{change}.},escapeinside={(*@}{@*)}, mathescape=true, basicstyle=\footnotesize, label={codigo:template_assercao_juntado_change}, language=OCL]{Name}
context Package::preCond(el: String | Integer | Real | Boolean)
pre : Package.name <> el
context Package::postCond(el: String | Integer | Real | Boolean)
post : Package.name = el
\end{codigo}


%É importante observar que os passos apresentados neste capítulo não têm a preocupação de ensinar como escrever/implementar as restrições das refatorações utilizando OCL. Assim, o engenheiro de modernização é responsável por criar e implementar todas as pré- e pós-condições de uma dada refatoração para o KDM.



%Com o intuito de facilitar a visualização, formalização e entendimento das refatorações criadas para o metamodelo KDM, as refatorações aqui apresentadas utilizam duas especificações~\cite{staron2004implementing}: (\textit{i}) especificação informal e (\textit{ii}) especificação formal. Na especificação informal a ideologia da reforação é expressada, usualmente essa ideologia é definida por meio de linguagem natural. A especificação formal é responsável por representar as pré- e pós-condições, bem como a transformação/refatoração em OCL e ATL, respectivamente. Acredita-se que ambas especificações são úteis para o engenheiro de modernização - a especificação informal é utilizada para facilitar a compreensão e o propósito da refatoração, enquanto que a especificação formal facilita a implementação da refatoração. Além disso, a especificação formal é de extrema importância para facilitar a automação das refatorações. Maiores detalhes sobre essas especificações são apresentados na Subseção~\ref{sec:template_refatoracao}.

\subsection{Especificar Refatoração}\label{sec:template_refatoracao}

O último passo da abordagem é a especificação da refatoração. Esse último passo é opcional e fica a critério do engenheiro de modernização se irá ou não documentar a refatoração criada. Caso, o engenheiro de modernização opte por disponibilizar uma documentação deve-se então seguir as especificações definidas nesse passo.

Dessa forma, após definir a refatoração, sua implementação, bem como suas pré- e pós-condições para o metamodelo KDM é importante documentar a refatoração criada. Dessa forma, para facilitar a visualização, formalização e entendimento das refatorações criadas para o metamodelo KDM, os engenheiros de modernização podem especificar as refatorações criadas seguindo duas especificações~\cite{staron2004implementing}: (\textit{i}) especificação informal e (\textit{ii}) especificação formal. 

Na especificação informal a ideologia da refatoração é expressada, usualmente essa ideologia é definida por meio de linguagem natural. A especificação formal é responsável por representar as pré- e pós-condições, bem como a transformação/refatoração em OCL e ATL, respectivamente. Acredita-se que ambas especificações são úteis para o engenheiro de modernização - a especificação informal é utilizada para facilitar a compreensão e o propósito da refatoração, enquanto que a especificação formal facilita a implementação da refatoração. Além disso, a especificação formal é de extrema importância para facilitar a automação das refatorações. 
%
%
%
%Dado a Definição~\ref{def:refatoracao} de refatoração no contexto desta Tese é importante apresentar como cada refatoração é especificada. Como já salientado, as refatorações são definidas utilizando duas especificações, informal e formal. Assim, 
%
As refatorações para o metamodelo KDM devem ser especificadas utilizando os seguintes \textit{templates}:

\begin{enumerate}
	\item Especificação Informal:
		\begin{enumerate}
			\item Nome: o nome da refatoração;
			\item Definição: uma lista contendo os parâmetros utilizados na refatoração - após a definição dos parâmetros, eles são utilizados e referenciados dentro das especificações formal e informal por meio de \{...\};
			\item Objetivo: o objetivo da refatoração;
			\item Descrição (opcional): uma pequena explicação da refatoração;
			\item Pré-condição: uma lista de asserção que tem que ser verdade antes de realizar a refatoração;
			\item Pós-condição: uma lista de asserção que tem que ser verdade após a realização da refatoração;
			\item Mecanismo: um mecanismo de transformação descrevendo todos os passos da refatoração;
			\item Algoritmo: um algoritmo que descreve a refatoração.
		\end{enumerate}
	\item Especificação Formal:
		\begin{enumerate}
			\item Pré-condição: a pré-condição expressa em OCL;
			\item Algoritmo: a refatoração (\textit{model transformation}) definida em ATL;
			\item Pós-condição: a pós-condição expressa em OCL.
		\end{enumerate}
\end{enumerate}


\section{Exemplo de uso da abordagem de criação das refatorações}\label{sec:catalogo_refatoracao_kdm}

Para facilitar o entendimento de como as refatorações são criadas para o metamodelo KDM, nesta seção são apresentadas algumas refatorações que foram criadas para o KDM seguindo os passos descritos anteriormente. As refatorações que foram criadas para o metamodelo KDM podem ser visualizadas na Tabela~\ref{tab:refatoringsCatalogo}. Porém, nesse capítulo apenas algumas refatorações são detalhadas. As refatorações apresentadas na Tabela~\ref{tab:refatoringsCatalogo} foram implementadas em um ambiente computacional denominado KDM-RE apresentado no Capítulo~\ref{chapter:ferramenta_kdm_re}. Nas próximas seções as refatorações \textit{Push Down Attribute} e \textit{Extract Class} são apresentadas e detalhadas. %Todas as refatorações são definidas programaticamente utilizando a linguagem de transformação ATL. A linguagem de restrição utilizada nas refatorações foi a OCL. Todas as refatorações aqui criadas são especificadas/documentadas utilizando o \textit{template} apresentado anteriormente.


 %O apoio computacional, KDM-RE apresentado no Capítulo X, implementa todas as refatorações descritas na Tabela~\ref{tab:refatoringsCatalogo}.

		
%--------------------------
\subsection{Criar Refatoração \textit{Push Down Attribute}}
Nesta seção a refatoração \textit{Push Down Attribute} é criado seguinte os passos descritos neste capítulo. Essa refatoração é utilizada para remover a generalização de atributos, ou seja, um atributo é apenas utilizado em algumas subclasses não em todas, assim, não é interessante manter a generalização do atributo na superclasse, uma vez que cada subclasse pode definir um comportamento para o atributo~\cite{Fowler1999}.


\subsubsection{Identificar Elementos Estruturais}
O primeiro passo da abordagem consiste na identificação do elemento estrutural a ser refatorado. Pelo nome da refatoração é possível identificar que o elemento estrutural a ser refatorado é um atributo (do inglês - \textit{attribute}). Dessa forma, utilizando o artefato de mapeamento entre KDM e POO (ver Tabela~\ref{tab:mapemanetoEntreOOPeKDM}) é possível identificar que um atributo em KDM é representado pela metaclasse \texttt{StorableUnit}.

\subsubsection{Identificar Operações}
No segundo passo da abordagem o engenheiro de modernização deve identificar as operações atômicas que compõem a refatoração a ser criada. Na Figura~\ref{fig:antes_e_depois_pushDown_StorableUnit} duas instâncias simplificada do KDM são ilustradas, a parte superior ilustra a instância antes da realização da refatoração \textit{Push Down Attribute} e a parte inferior representa o resultado da refatoração. Como observado, o primeiro passo da refatoração \textit{Push Down Attribute} é selecionar um específico \texttt{StorableUnit}, Figura~\ref{fig:antes_e_depois_pushDown_StorableUnit} \ding{202}. Em seguida, deve-se selecionar as subclasses que realmente utilizam esse \texttt{StorableUnit} para move-lo, com ilustrado na Figura~\ref{fig:antes_e_depois_pushDown_StorableUnit} \ding{203}. Posteriormente o \{\texttt{StorableUnit}Selecionado\} é movido para as sub-\texttt{ClassUnit}Selecionadas, como ilustrado na parte inferior da Figura~\ref{fig:antes_e_depois_pushDown_StorableUnit} \ding{205}. Note que a instância da \texttt{ClassUnit} que havia o \{\texttt{StorableUnit}Selecionado\} não possui mais sua instância, como apresentado na Figura~\ref{fig:antes_e_depois_pushDown_StorableUnit} \ding{204}. Observando a Figura~\ref{fig:antes_e_depois_pushDown_StorableUnit} é possível identificar que é a refatoração \textit{Push Down Attribute} pode ser criada por meio da combinação das seguintes operações atômicas: (\textit{i}) \texttt{add} e (\textit{ii}) \texttt{delete}. 

\begin{figure}[h]
	\centering
	% Requires \usepackage{graphicx}
	\caption{Instância simplificada do KDM antes e depois da refatoração \textit{Push Down Attribute}.}
	\label{fig:antes_e_depois_pushDown_StorableUnit}
	\includegraphics[scale=0.6]{images/pushDownStorableUnitAntesDepois2}
	\fautor
\end{figure}

\subsubsection{Implementar Refatoração}

Após identificar as operações que compõem a refatoração a ser criada, o próximo passo consiste na implementação da refatoração. O terceiro passo da abordagem é apoiado por um conjunto de \textit{templates} que auxiliam o engenheiro de modernização a criar a refatoração. As operações atômicas identificadas para implementar a refatoração \textit{Push Down Attribute} foram implementadas em ATL utilizando os \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:template_addKDMElement} e~\ref{codigo:template_delete}. A combinação desses \textit{templates} resulta no Código-fonte~\ref{codigo:push_Down_StorableUnit_ATL}.


\begin{codigo}[caption={[ATL representando a refatoração \textit{Push Down Attribute}.] ATL da refatoração \textit{Push Down Attribute}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:push_Down_StorableUnit_ATL}, language=ATL]{Name}
module pushDownStorableUnit;
create OUT : MM refining IN : MM;
rule createStorableUnit {
	from
		source : MM!ClassUnit (source.name = (*@\aspas{\{sub-\texttt{ClassUnit}Selecionada\}}@*)
	to 
		target : MM!ClassUnit (
			codeElement(*@$\leftarrow$@*)source.codeElement(*@$\rightarrow$@*)including(newElement)
		),
		newElement: MM!StorableUnit (
			name(*@$\leftarrow$@*)(*@\{\texttt{StorableUnit}Selecionado.name\}@*)
		)
}
rule deleteStorableUnit {
	from
		source : MM!StorableUnit (source.name = (*@\{\texttt{StorableUnit}Selecionado.name\}@*) and source.refImmediateComposite().name = (*@\{\texttt{ClassUnit}.name\}@*) )
	to
		drop
}
\end{codigo}

\subsubsection{Definir Restrições}

Após identificar as operações que compõem a refatoração e implementar a refatoração utilizando os \textit{templates} definidos na abordagem, o próximo passo consiste na definição de asserções (pré- e pós-condições) da refatoração. Para cada operação atômica identifica no segundo passo da abordagem \textit{templates} são disponibilizados para auxiliar o engenheiro de modernização a criar tais asserções. No Código-fonte~\ref{codigo:precondicao_push_down_attribute} é apresentado a pré-condição criada para a refatoração \textit{Push Down Attribute}. Essa pré-condição foi criada utilizando uma combinação dos \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:pre_template_add} e~\ref{codigo:pre_template_delete}. Similarmente no Código-fonte~\ref{codigo:poscondicao_push_down_attribute2} é apresentado a pós-condição criada para a refatoração \textit{Push Down Attribute}.


\begin{codigo}[caption={[Pré-condição da refatoração \textit{Push Down Attribute}.] Pré-condição da refatoração \textit{Push Down Attribute}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:precondicao_push_down_attribute}, language=OCL]{Name}
context StorableUnit::preCond(newName: String)
pre : ClassUnit.allInstances->select(e : ClassUnit | a.name = (*@\aspas{\{sub-\texttt{ClassUnit}Selecionada\}}@*) and not StorableUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : StorableUnit | e.name = newName) 
and ClassUnit.allInstances->select(e : ClassUnit | a.name = (*@\{\texttt{ClassUnit}.name\}@*)) and StorableUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : StorableUnit | e.name = newName)
\end{codigo}

\begin{codigo}[caption={[Pós-condição da refatoração \textit{Push Down Attribute}.] Pós-condição da refatoração \textit{Push Down Attribute}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:poscondicao_push_down_attribute2}, language=OCL]{Name}
context StorableUnit::preCond(newName: String)
post : ClassUnit.allInstances->select(e : ClassUnit | a.name = (*@\aspas{\{sub-\texttt{ClassUnit}Selecionada\}}@*) and StorableUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : StorableUnit | e.name = newName) 
and ClassUnit.allInstances->select(e : ClassUnit | a.name = (*@\{\texttt{ClassUnit}.name\}@*)) and not StorableUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : StorableUnit | e.name = newName)
\end{codigo}


\subsubsection{Especificar Refatoração}

O último passo da abordagem é a especificação da refatoração e é um passo opcional e fica a critério do engenheiro de modernização criar ou não a documentação da refatoração criada. Para os exemplos apresentado nesse capítulo escolheu-se especificar as refatorações criadas seguindo o \textit{template} apresentado na Seção~\ref{sec:template_refatoracao}.

\begin{enumerate}
	\item Especificação Informal:
		\begin{enumerate}
			\item Nome: \textit{Push Down Attribute};
			\item Definição:
			    \begin{itemize}
			        \item \texttt{StorableUnit}Selecionado - um atributo que será movido para subclasses;
			        \item \texttt{ClassUnit} - uma classe na qual o \{\texttt{StorableUnit}Selecionado\} é definido;
			        \item sub-\texttt{ClassUnit}Selecionadas - subclasses de \{\texttt{ClassUnit}\}.
			    \end{itemize}
			\item Objetivo: Mover um \{\texttt{StorableUnit}Selecionado\} para as \{sub-\texttt{ClassUnit}Selecionadas\}.
			\item Descrição (opcional): \{\texttt{StorableUnit}Selecionado\} é utilizada em apenas algumas subclasses.
			\item Pré-condição:
			    \begin{itemize}
			        \item \{\texttt{StorableUnit}Selecionado\} não existe nas sub-\texttt{ClassUnit}Selecionadas; 
			        \item \{\texttt{StorableUnit}Selecionado\} existe na \texttt{ClassUnit}. 
			    \end{itemize}
			\item Pós-condição:
			    \begin{itemize}
			        \item \{\texttt{StorableUnit}Selecionado\} existe nas sub-\texttt{ClassUnit}Selecionadas;
			        \item \{\texttt{StorableUnit}Selecionado\} não existe na \texttt{ClassUnit}.
			    \end{itemize}
			\item Mecanismo: move um atributo de uma classe para todas suas subclasses;
			\item Algoritmo: 
			    \begin{itemize}
			        \item para cada sub-\texttt{ClassUnit}Selecionadas que realmente usa o \{\texttt{StorableUnit}Selecionado\} - sub-\texttt{ClassUnit}Selecionadas.add(\{\texttt{StorableUnit}Selecionado\})
			        \item \{\texttt{ClassUnit}\}.delete(\{\texttt{StorableUnit}Selecionado\}). 
			    \end{itemize} 
	    \end{enumerate}
		\item Especificação Formal:
		\begin{enumerate}
			\item Pré-condição: a pré-condição da refatoração \textit{Push Down Attribute} é apresentada no Código-fonte~\ref{codigo:precondicao_push_down_attribute};
			\item Algoritmo: a ATL responsável por realizar a refatoração \textit{Push Down Attribute} é apresentada no Código-fonte~\ref{codigo:push_Down_StorableUnit_ATL}
			\item Pós-condição: a pós-condição da refatoração \textit{Push Down Attribute} é apresentada no Código-fonte~\ref{codigo:poscondicao_push_down_attribute2};
		\end{enumerate}
	\end{enumerate}		
	
	
	
%--------------------------
\subsection{Criar Refatoração \textit{Extract Class}}
A refatoração \textit{Extract Class} deve ser utilizada quando uma determinada classe está fazendo o trabalho que deveria ser realizada por duas classes~\cite{Fowler1999}. Dessa forma, nesta seção a refatoração \textit{Extract Class} é criada seguindo todos os passos da abordagem. 

\subsubsection{Identificar Elementos Estruturais}

A refatoração \textit{Extract Class} basicamente consiste no encapsulamento de atributos de uma classe maior em outra classe. Dessa forma, os elementos estruturais utilizados na refatoração são: (\textit{i}) classes e (\textit{ii}) atributos. Utilizando o artefato apresentado na Tabela~\ref{tab:mapemanetoEntreOOPeKDM} é possível identificar que as metaclasses em KDM que representa esses elementos estruturais são \texttt{ClassUnit} e \texttt{StorableUnit}.

\subsubsection{Identificar Operações}

No segundo passo da abordagem deve-se identificar as operações atômicas que compõem a refatoração a ser criada. Na Figura~\ref{fig:antes_e_depois_extract_ClassUnit} são apresentadas duas instâncias simplificada do KDM, uma representa a instância antes da refatoração e a outra representa após a aplicação da refatoração. 

\begin{figure}[h]
	\centering
	% Requires \usepackage{graphicx}
	\caption{Instância simplificada do KDM antes e depois da refatoração \textit{Extract Class}.}
	\label{fig:antes_e_depois_extract_ClassUnit}
	\includegraphics[scale=0.6]{images/extractClassUnitAntesEDepois2}
	\fautor
\end{figure}

O primeiro passo da refatoração \textit{Extract ClassUnit} é selecionar um conjunto de \texttt{StorableUnits} que serão adicionados para uma nova instância de metaclasse \texttt{ClassUnit}, no exemplo ilustrado na Figura~\ref{fig:antes_e_depois_extract_ClassUnit} \ding{202} duas instâncias de \texttt{StorableUnits} são selecionadas, \texttt{att1} e \texttt{att2}. Em seguida, uma instância da metaclasse \texttt{ClassUnit} é criada e adicionada ao mesmo \texttt{Package} que a instância da metaclasse \texttt{ClassUnit} e que contém os \{\texttt{StorableUnit}Selecionados\}, como ilustrado na Figura~\ref{fig:antes_e_depois_extract_ClassUnit} \ding{204}. Em seguida, todos os \{\texttt{StorableUnit}Selecionados\} são adicionados nessa nova instância, como representado na Figura~\ref{fig:antes_e_depois_extract_ClassUnit} \ding{203}. Além disso, os \{\texttt{StorableUnit}Selecionados\} devem ser deletados da \{\texttt{ClassUnit}Selecionada\}. Observando a Figura~\ref{fig:antes_e_depois_extract_ClassUnit} é possível identificar que é a refatoração \textit{Extract Class} pode ser criada por meio da combinação das seguintes operações atômicas: (\textit{i}) \texttt{add} e (\textit{ii}) \texttt{delete}. 

%Mais especificadamente deve-se \texttt{add} uma instância de \texttt{ClassUnit}, \texttt{add} uma instância de \texttt{StorableUnit} na instância de \texttt{ClassUnit} criada e posteriormente deve-se \texttt{delete} 

\subsubsection{Implementar Refatoração}

No passo anterior identificou-se que as operações atômicas \texttt{add} e \texttt{delete} quando combinadas podem  compor e criar a refatoração \textit{Extract Class}. Dessa forma, essas operações atômicas foram implementadas em ATL utilizando os \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:template_addKDMElement} e~\ref{codigo:template_delete}. A combinação desses \textit{templates} resultou no Código-fonte~\ref{codigo:extract_classUnit_ATL}. 

\begin{codigo}[caption={[ATL representando a refatoração \textit{Extract ClassUnit}.] ATL da refatoração \textit{Extract ClassUnit}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:extract_classUnit_ATL}, language=ATL]{Name}
module extractClassUnit;
create OUT : MM refining IN : MM;
rule deleteStorableUnit {
	from
		source : MM!StorableUnit (source.name = (*@\aspas{\{StorableUnit\}Selecionado}@*))
	to 
		drop
}
rule createClassUnit {
	from
		source : MM!Package (source.name = (*@\aspas{\{\texttt{Package}\}}@*))
	to 
		target: MM!Package (
			codeElement(*@$\leftarrow$@*)source.codeElement(*@$\rightarrow$@*)including(newElement)
		),
		newElement: MM!ClassUnit (
			name(*@$\leftarrow$@*)(*@\aspas{\{newName\}}@*)
		)
}
rule createStorableUnit {
	from
		source : MM!ClassUnit (source.name = (*@\aspas{\{newName\}}@*))
	to 
		target: MM!ClassUnit (
			codeElement(*@$\leftarrow$@*)source.codeElement(*@$\rightarrow$@*)including(newElement)
		),
		newElement: MM!StorableUnit (
			name(*@$\leftarrow$@*)(*@\aspas{storableUnitName}@*)
		)
}}
\end{codigo}

Nas linhas 3-8 uma instância de \texttt{StorableUnit} é deletada. Nas linhas 9-19 uma instância da metaclasse \texttt{ClassUnit} é criada. Finalmente, nas linhas 14-24 uma instância da metaclasse \texttt{StorableUnit} é criada e adicionada na instância da metaclasse \texttt{ClassUnit} recém criada.

\subsubsection{Definir Restrições}

Após identificar as operações e implementar a refatoração o próximo passo consiste na definição das pré- e pós-condições da refatoração. Os \textit{templates} apresentados nesse capítulo foram utilizados para criar as asserções da refatoração \textit{Extract Class}. O Código-fonte~\ref{codigo:precondicao_extractClass} apresenta a pré-condição criada para a refatoração. Essa pré-condição foi criada utilizando os \textit{templates} apresentados nos Códigos-fontes~\ref{codigo:pre_template_add} e~\ref{codigo:pre_template_delete}. Similarmente no Código-fonte~\ref{codigo:poscondicao_extractClass} é apresentado a pós-condição criada para a refatoração \textit{Extract ClassUnit}.

\begin{codigo}[caption={[Pré-condição da refatoração \textit{Extract Class}.] Pré-condição da refatoração \textit{Extract Class}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:precondicao_extractClass}, language=OCL]{Name}
context StorableUnit::preCond(newName: String)
pre : ClassUnit.allInstances->select(e : ClassUnit | a.name = (*@\{\texttt{ClassUnit}Selecionada\}@*)) and StorableUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : StorableUnit | e.name = (*@\{\texttt{StorableUnit}Selecionado\}@*))
and Package.allInstances->select(e : Package | a.name = (*@\aspas{\{Package\}}@*) and not ClassUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : ClassUnit | e.name = newName) 
and ClassUnit.allInstances->select(e : ClassUnit | a.name = newName and not StorableUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : StorableUnit | e.name = (*@\{\texttt{StorableUnit}Selecionado\}@*).name) 
\end{codigo}

\begin{codigo}[caption={[Pós-condição da refatoração \textit{Extract ClassUnit}.] Pós-condição da refatoração \textit{Extract ClassUnit}.},escapeinside={(*@}{@*)}, basicstyle=\footnotesize, label={codigo:poscondicao_extractClass}, language=OCL]{Name}
context StorableUnit::preCond(newName: String)
post : ClassUnit.allInstances->select(e : ClassUnit | a.name = (*@\{\texttt{ClassUnit}Selecionada\}@*)) and not StorableUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : StorableUnit | e.name = (*@\{\texttt{StorableUnit}Selecionado\}@*).name)
and Package.allInstances->select(e : Package | a.name = (*@\aspas{\{Package\}}@*) and ClassUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : ClassUnit | e.name = newName) 
and ClassUnit.allInstances->select(e : ClassUnit | a.name = newName and StorableUnit.refImmediateComposite().codeElement(*@$\rightarrow$@*)exist (e : StorableUnit | e.name = (*@\{\texttt{StorableUnit}Selecionado\}@*).name) 
\end{codigo}

\subsubsection{Especificar Refatoração}

O último passo da abordagem é a especificação da refatoração criada. Esse passo é opcional e fica a critério do engenheiro de modernização realizar esse passo. Para a refatoração \textit{Extract ClassUnit} escolheu-se realizar o passo da especificação da refatoração seguindo o \textit{template} apresentado na Seção~\ref{sec:template_refatoracao}.


\begin{enumerate}
	\item Especificação Informal:
		\begin{enumerate}
			\item Nome: \textit{Extract ClassUnit};
			\item Definição:
			    \begin{itemize}
			        \item \texttt{Package} - uma instância da metaclasse \texttt{Package} para adicionar a nova \texttt{ClassUnit};
			        \item \texttt{ClassUnit}Selecionada - a classe que contém os atributos e métodos que devem ser movido para a nova classe;
			        \item novoNome - um novo nome para a nova classe a ser criada;
			        \item \texttt{StorableUnit}Selecionado - atributo selecionado para ser movido para a nova classe.
			    \end{itemize}
			\item Objetivo: Criar uma nova \texttt{ClassUnit} e mover o \texttt{StorableUnit}Selecionado para essa nova instância.
			\item Descrição (opcional): \texttt{ClassUnit}Selecionada está realizando o trabalho que deveria ser realizado por duas classes.
			\item Pré-condição:
			    \begin{itemize}
			        \item \{\texttt{StorableUnit}Selecionado\} existe na \{\texttt{ClassUnit}Selecionada\};
			        \item nova \texttt{ClassUnit} não existe no \texttt{Package};
			        \item \{\texttt{StorableUnit}Selecionado\} não existe na nova \texttt{ClassUnit}.
			    \end{itemize}
			\item Pós-condição:
			    \begin{itemize}
			        
			        \item \{\texttt{StorableUnit}Selecionado\} não existe na \{\texttt{ClassUnit}Selecionada\};
			        \item nova \texttt{ClassUnit} existe no \texttt{Package};
			        \item \{\texttt{StorableUnit}Selecionado\} existe na nova \texttt{ClassUnit}.
			    \end{itemize}
			\item Mecanismo: Deve-se criar uma nova classe e mover os atributos selecionados;
			\item Algoritmo: 
			    \begin{itemize}
			        \item addNewClassUnit(\{novoNome\});
			        \item adiciona essa nova instância dentro de um \texttt{Package};
			        \item para cada \{\texttt{StorableUnit}Selecionado\} - add(\{newClassUnit\}, \{\texttt{StorableUnit}\-Selecionado\});
			        \item para cada \{\texttt{StorableUnit}Selecionado\} - delete(\{\texttt{ClassUnit}Selecionada\}, \{\texttt{Storable\-Unit}Selecionado\});
			        %\item createNewHasType(\{newClassUnit\}, \{\texttt{ClassUnit}Selecionada\}).
			    \end{itemize} 
	    \end{enumerate}
		\item Especificação Formal:
		\begin{enumerate}
			\item Pré-condição: a pré-condição da refatoração \textit{Extract Class} é apresentada no Código-fonte~\ref{codigo:precondicao_extractClass};
			\item Algoritmo: a ATL responsável por realizar a refatoração \textit{Extract Class} é apresentada no Código-fonte~\ref{codigo:extract_classUnit_ATL};
			\item Pós-condição: a pós-condição da refatoração \textit{Extract Class} é apresentada no Código-fonte~\ref{codigo:poscondicao_extractClass};
		\end{enumerate}
\end{enumerate}
	
	
\section{Considerações Finais}\label{sec:consideracoes_finais_capitulo_reforacao}

Neste capítulo foram apresentadas cinco passos para auxiliar o engenheiro de modernização a criar refatorações para o metamodelo KDM. Com o intuito de exemplificar esses cinco passos foram escolhidas algumas refatorações propostas por~\citeonline{Fowler1999} para serem criadas para o metamodelo KDM. %Embora ~\citeonline{Fowler1999} tenha definido um catálogo de refatoração para ser utilizado em código-fonte, mais de 60\% das refatorações (44 de 72) são ilustradas e explicadas utilizando modelos, mais especificadamente diagramas de classes da UML. Esta observação fez com que tais refatorações fossem criadas para o metamodelo KDM. 

Antes de criar qualquer refatoração para o metamodelo KDM, o primeiro passo diz que é  necessário identificar as metaclasses do KDM que têm características similares aos conceitos do POO, bem como instruções comumente utilizadas em todas as linguagens de programação, tais como, ramificações, iterações, etc. Dessa forma, esse capítulo também apresentou um mapeamento entre os conceitos do POO e o metamodelo KDM. Acredita-se que engenheiros de modernização pouco familiarizado com o metamodelo KDM podem gastar menos tempo durante a criação de novas refatorações com a utilização deste mapeamento, assim, qualquer exemplo de refatoração pode ser facilmente adaptada para o metamodelo KDM seguindo esse mapeamento, bem como os passos aqui apresentados.

Após identificar todos os elementos estruturais e identificar o mapeamento entre POO e o metamodelo KDM, o próximo passo é escolher qual refatoração criar. No contexto desta Tese todas as refatorações podem ser agrupadas em nível de granularidade. As granularidades podem ser definidas em dois níveis de operações: (\textit{i}) operação atômica e (\textit{ii}) operações compostas. As granularidades definidas como operações atômicas podem ser especificas por meio de operações primitivas (\texttt{addd}, \texttt{delete} e \texttt{change}). As refatorações de granularidade compostas são uma combinação de operações atômicas (ver Tabela~\ref{tab:refatoringsCatalogo}). Em seguida no próximo passo o engenheiro de modernização deve implementar a refatoração por meio da linguagem de transformação ATL. Dessa forma, \textit{templates} foram criados para auxiliar os engenheiros de modernização a implementar refatorações utilizando a linguagem ATL. Posteriormente, o engenheiro de modernização deve implementar as restrições (pré- e pós-condições) da refatoração.

Após criar uma determinada refatoração, bem como suas pré- e pós-condições para o metamodelo KDM, o engenheiro de modernização deve especificar e documentar a refatoração. As refatoração criadas para o metamodelo KDM consistem de duas principais especificações - uma especificação informal e uma especificação formal. Na especificação informal a ideologia básica é permitir que o engenheiro de modernização expresse o propósito da refatoração por meio de linguagem natural. A segunda especificação é responsável por representar as pré- e pós-condições, bem como a transformação/refatoração propriamente dita em linguagens executáveis - OCL e ATL foram utilizadas, respectivamente. Ambas especificações são úteis para o engenheiro de modernização -a especificação informal é utilizada para facilitar a compreensão e o propósito da refatoração,enquanto que a especificação formal facilita a implementação da refatoração. Além disso, a especificação formal é de extrema importância para facilitar a automação das refatorações. %É importante destacar que neste capítulo apenas as refatorações \textit{Rename ClassUnit}, \textit{Pull Up StorableUnit}, \textit{Push Down StorableUnit} e \textit{Extract ClassUnit} são apresentadas e detalhadas.

Seguindo os passos apresentados neste capítulo o engenheiro de modernização pode criar refatorações para o metamodelo KDM. No entanto, as especificações formais e informais resultantes não são suficientes para promover o reúso de refatorações no contexto do metamodelo KDM. Dessa forma, no Capítulo~\ref{chapter:Toward_a_Refactoring_Metamodel_for_KDM} é apresentado um metamodelo para auxiliar o engenheiro de modernização a promover o reúso de refatorações no contexto do metamodelo KDM. Com a utilização desse metamodelo, informações (metadados) sobre refatorações podem ser reutilizadas de forma independente de linguagem e plataforma. %No Capítulo~\ref{chapter:Abordagem_de_sincronizacao} uma abordagem para manter instâncias do metamodelo KDM sincronizada e consiste após a aplicação de refatoração é apresentada. 
No Capítulo~\ref{chapter:ferramenta_kdm_re} é apresentado um apoio computacional denominado KDM-RE. Esse apoio computacional é composto por três \textit{plug-ins} do Eclipse: (\textit{i}) o primeiro consiste em um conjunto de \textit{Wizards} que apoia o engenheiro de software na aplicação das refatorações em diagramas de classe UML; (\textit{ii}) o segundo consiste em um módulo de propagação de mudanças que permite manter modelos internos do KDM sincronizados e; (\textit{iii}) o terceiro consiste em um apoio à importação e reúso de refatorações disponíveis no repositório.
